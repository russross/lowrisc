#!/usr/bin/env python3

import argparse
import ctypes
import curses
import dataclasses
import itertools
import os
import re
import sys
import struct
from typing import Callable, Optional, TypeAlias

MISALIGNED_OKAY = True

class Machine:
    def __init__(self,
            memory_start: int, memory_end: int, pc_start: int,
            text_start: int, text_end: int, text_symbols: dict[int, str],
            data_start: int, data_end: int, data_symbols: dict[int, str],
            other_symbols: dict[int, str], global_pointer: int) -> None:
        # allocate memory
        assert(memory_start >= 4096)
        assert(memory_end > memory_start)
        assert(memory_start & 0xfff == 0)
        assert(memory_end & 0xfff == 0)
        self.memory = bytearray(memory_end - memory_start)
        self.memory_start = memory_start
        self.memory_end = memory_end
        self.pc_start = pc_start
        self.text_start = text_start
        self.text_end = text_end
        self.text_symbols = text_symbols
        self.data_start = data_start
        self.data_end = data_end
        self.data_symbols = data_symbols
        self.other_symbols = other_symbols
        self.global_pointer = global_pointer
        self.stdout = bytearray()
        self.stdin = bytearray()
        self.stack_frames: list[int] = []

        # allocate a stack with a guard page
        self.stack = bytearray(4096)
        self.stack_start = 0x1000000 - 4096
        if self.stack_start < memory_end + 4096:
            self.stack_start = memory_end + 4096
        self.stack_end = self.stack_start + 4096

        # set up cpu state
        self.x = [0] * 32
        self.pc = pc_start
        self.x[2] = self.stack_end

        # set up tracing
        self.old_pc = 0
        self.reads: list[Value] = []
        self.writes: list[Value] = []
        self.undos: list[Value] = []
        self.stdin_delta: Optional[bytes] = None
        self.stdout_delta: Optional[bytes] = None
        self.other_message: Optional[str] = None
        self.terminate = False
        self.most_recent_memory = data_start if data_start > 0 else self.stack_end - 8
        self.most_recent_data = (data_start, 0)
        self.most_recent_stack = (self.stack_end, 0)
        self.function_start: Optional[int] = None
        self.function_end: Optional[int] = None

    def get_byte(self, addr: int) -> int:
        if      not (addr >= self.data_start and addr < self.data_end) and \
                not (addr >= self.stack_start  and addr < self.stack_end):
            raise Fault(f'segfault: get_byte addr={addr:x}')
        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+1 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+1 - self.stack_start]

        return int.from_bytes(raw, byteorder='little', signed=False)

    def load(self, addr: int, size: int) -> bytes:
        if      not (addr >= self.data_start and addr+size <= self.data_end) and \
                not (addr >= self.stack_start  and addr+size <= self.stack_end):
            raise Fault(f'segfault: load addr={addr:x} size={size}')
        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+size - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+size - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, False))
        return raw

    def lb(self, addr: int) -> int:
        if      not (addr >= self.data_start and addr < self.data_end) and \
                not (addr >= self.stack_start  and addr < self.stack_end):
            raise Fault(f'segfault: lb addr={addr:x}')
        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+1 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+1 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, True))
        return int.from_bytes(raw, byteorder='little', signed=True)

    def lh(self, addr: int) -> int:
        if not MISALIGNED_OKAY and (addr & 1) != 0:
            raise Fault(f'bus error: lh addr={addr:x}')
        if      not (addr >= self.data_start and addr+1 < self.data_end) and \
                not (addr >= self.stack_start  and addr+1 < self.stack_end):
            raise Fault(f'segfault: lh addr={addr:x}')

        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+2 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+2 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, True))
        return int.from_bytes(raw, byteorder='little', signed=True)

    def lw(self, addr: int) -> int:
        if not MISALIGNED_OKAY and (addr & 3) != 0:
            raise Fault(f'bus error: lw addr={addr:x}')
        if      not (addr >= self.data_start and addr+3 < self.data_end) and \
                not (addr >= self.stack_start  and addr+3 < self.stack_end):
            raise Fault(f'segfault: lw addr={addr:x}')

        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+4 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+4 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, True))
        return int.from_bytes(raw, byteorder='little', signed=True)

    def ld(self, addr: int) -> int:
        if not MISALIGNED_OKAY and (addr & 7) != 0:
            raise Fault(f'bus error: ld addr={addr:x}')
        if      not (addr >= self.data_start and addr+7 < self.data_end) and \
                not (addr >= self.stack_start  and addr+7 < self.stack_end):
            raise Fault(f'segfault: ld addr={addr:x}')

        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+8 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+8 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, True))
        return int.from_bytes(raw, byteorder='little', signed=True)

    def lbu(self, addr: int) -> int:
        if      not (addr >= self.data_start and addr < self.data_end) and \
                not (addr >= self.stack_start  and addr < self.stack_end):
            raise Fault(f'segfault: lbu addr={addr:x}')

        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+1 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+1 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, False))
        return int.from_bytes(raw, byteorder='little', signed=False)

    def lhu(self, addr: int) -> int:
        if not MISALIGNED_OKAY and (addr & 1) != 0:
            raise Fault(f'bus error: lhu addr={addr:x}')
        if      not (addr >= self.data_start and addr+1 < self.data_end) and \
                not (addr >= self.stack_start  and addr+1 < self.stack_end):
            raise Fault(f'segfault: lhu addr={addr:x}')

        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+2 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+2 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, False))
        return int.from_bytes(raw, byteorder='little', signed=False)

    def lwu(self, addr: int) -> int:
        if not MISALIGNED_OKAY and (addr & 3) != 0:
            raise Fault(f'bus error: lwu addr={addr:x}')
        if      not (addr >= self.data_start and addr+3 < self.data_end) and \
                not (addr >= self.stack_start  and addr+3 < self.stack_end):
            raise Fault(f'segfault: lwu addr={addr:x}')

        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+4 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+4 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, False))
        return int.from_bytes(raw, byteorder='little', signed=False)

    def store(self, addr: int, raw: bytes) -> None:
        size = len(raw)
        if      not (addr >= self.data_start and addr+size <= self.data_end) and \
                not (addr >= self.stack_start  and addr+size <= self.stack_end):
            raise Fault(f'segfault: store addr={addr:x} size={size}')

        if addr < self.memory_end:
            old = self.memory[addr - self.memory_start: addr+size - self.memory_start]
            self.memory[addr - self.memory_start: addr+size - self.memory_start] = raw
        else:
            old = self.stack[addr - self.stack_start: addr+size - self.stack_start]
            self.stack[addr - self.stack_start: addr+size - self.stack_start] = raw

        self.writes.append(MemoryValue(addr, raw, True))
        self.undos.append(MemoryValue(addr, old, True))

    def set_byte(self, addr: int, value: int) -> None:
        if      not (addr >= self.memory_start and addr < self.memory_end) and \
                not (addr >= self.stack_start  and addr < self.stack_end):
            raise Fault(f'segfault: set_byte addr={addr:x}')

        raw = ctypes.c_int8(value).value.to_bytes(1, byteorder='little', signed=True)
        if addr < self.memory_end:
            for (i, b) in enumerate(raw):
                self.memory[addr+i - self.memory_start] = b
        else:
            for (i, b) in enumerate(raw):
                self.stack[addr+i - self.stack_start] = b

    def sb(self, addr: int, value: int) -> None:
        if      not (addr >= self.data_start and addr < self.data_end) and \
                not (addr >= self.stack_start  and addr < self.stack_end):
            raise Fault(f'segfault: sb addr={addr:x}')

        raw = ctypes.c_int8(value).value.to_bytes(1, byteorder='little', signed=True)
        if addr < self.memory_end:
            old = self.memory[addr - self.memory_start: addr+1 - self.memory_start]
            for (i, b) in enumerate(raw):
                self.memory[addr+i - self.memory_start] = b
        else:
            old = self.stack[addr - self.stack_start: addr+1 - self.stack_start]
            for (i, b) in enumerate(raw):
                self.stack[addr+i - self.stack_start] = b

        self.writes.append(MemoryValue(addr, raw, True))
        self.undos.append(MemoryValue(addr, old, True))

    def sh(self, addr: int, value: int) -> None:
        if not MISALIGNED_OKAY and (addr & 1) != 0:
            raise Fault(f'bus error: sh addr={addr:x}')
        if      not (addr >= self.data_start and addr+1 < self.data_end) and \
                not (addr >= self.stack_start  and addr+1 < self.stack_end):
            raise Fault(f'segfault: sh addr={addr:x}')

        raw = ctypes.c_int16(value).value.to_bytes(2, byteorder='little', signed=True)
        if addr < self.memory_end:
            old = self.memory[addr - self.memory_start: addr+2 - self.memory_start]
            for (i, b) in enumerate(raw):
                self.memory[addr+i - self.memory_start] = b
        else:
            old = self.stack[addr - self.stack_start: addr+2 - self.stack_start]
            for (i, b) in enumerate(raw):
                self.stack[addr+i - self.stack_start] = b

        self.writes.append(MemoryValue(addr, raw, True))
        self.undos.append(MemoryValue(addr, old, True))

    def sw(self, addr: int, value: int) -> None:
        if not MISALIGNED_OKAY and (addr & 3) != 0:
            raise Fault(f'bus error: sw addr={addr:x}')
        if      not (addr >= self.data_start and addr+3 < self.data_end) and \
                not (addr >= self.stack_start  and addr+3 < self.stack_end):
            raise Fault(f'segfault: sw addr={addr:x}')

        raw = ctypes.c_int32(value).value.to_bytes(4, byteorder='little', signed=True)
        if addr < self.memory_end:
            old = self.memory[addr - self.memory_start: addr+4 - self.memory_start]
            for (i, b) in enumerate(raw):
                self.memory[addr+i - self.memory_start] = b
        else:
            old = self.stack[addr - self.stack_start: addr+4 - self.stack_start]
            for (i, b) in enumerate(raw):
                self.stack[addr+i - self.stack_start] = b

        self.writes.append(MemoryValue(addr, raw, True))
        self.undos.append(MemoryValue(addr, old, True))

    def sd(self, addr: int, value: int) -> None:
        if not MISALIGNED_OKAY and (addr & 7) != 0:
            raise Fault(f'bus error: sd addr={addr:x}')
        if      not (addr >= self.data_start and addr+7 < self.data_end) and \
                not (addr >= self.stack_start  and addr+7 < self.stack_end):
            raise Fault(f'segfault: sd addr={addr:x}')

        raw = ctypes.c_int64(value).value.to_bytes(8, byteorder='little', signed=True)
        if addr < self.memory_end:
            old = self.memory[addr - self.memory_start: addr+8 - self.memory_start]
            for (i, b) in enumerate(raw):
                self.memory[addr+i - self.memory_start] = b
        else:
            old = self.stack[addr - self.stack_start: addr+8 - self.stack_start]
            for (i, b) in enumerate(raw):
                self.stack[addr+i - self.stack_start] = b

        self.writes.append(MemoryValue(addr, raw, True))
        self.undos.append(MemoryValue(addr, old, True))

    def load_instruction(self, addr: int) -> int:
        if not MISALIGNED_OKAY and (addr & 3) != 0:
            raise Fault(f'bus error: load_instruction addr={addr:x}')
        if not (addr >= self.text_start and addr+3 < self.text_end):
            raise Fault(f'segfault: load_instruction addr={addr:x}')

        raw = self.memory[addr - self.memory_start: addr+4 - self.memory_start]
        return int.from_bytes(raw, byteorder='little', signed=True)

    def get(self, reg: int) -> int:
        if reg != 0:
            dup = False
            for elt in self.reads:
                match elt:
                    case RegisterValue(rs, _) if rs == reg:
                        dup = True
            if not dup:
                self.reads.append(RegisterValue(reg, self.x[reg]))
        return self.x[reg]

    def set(self, reg: int, value: int) -> None:
        # zero register never changes
        if reg != 0:
            self.writes.append(RegisterValue(reg, clip(value)))
            self.undos.append(RegisterValue(reg, self.x[reg]))
            self.x[reg] = clip(value)

    def set32(self, reg: int, value: int) -> None:
        # zero register never changes
        if reg != 0:
            self.writes.append(RegisterValue(reg, clip32(value)))
            self.undos.append(RegisterValue(reg, self.x[reg]))
            self.x[reg] = clip32(value)

    def set_pc(self, value: int) -> None:
        self.old_pc = self.pc
        self.pc = clip(value)
        if self.pc & 3 != 0:
            raise Fault(f'bus error: pc addr={self.pc}')

    def mark_function_start(self) -> None:
        sp = self.get(r.index('sp'))
        self.function_start = sp
        self.stack_frames.append(sp)

    def mark_function_end(self) -> None:
        sp = self.get(r.index('sp'))
        self.function_end = sp
        self.stack_frames.pop()

    def gather_effects(self) -> 'Effects':
        e = Effects((self.old_pc, self.pc),
            self.reads, self.writes, self.undos,
            self.stdin_delta, self.stdout_delta,
            self.other_message, self.terminate,
            self.function_start, self.function_end)
        self.reads = []
        self.writes = []
        self.undos = []
        self.stdin_delta = None
        self.stdout_delta = None
        self.other_message = None
        self.terminate = False
        self.stack_frame = None
        self.function_start = None
        self.function_end = None
        return e

    def text_label(self, addr: int, pc: int = 0) -> str:
        if addr in self.text_symbols:
            return f'{self.text_symbols[addr]}/{hex(addr)}'
        else:
            return str(addr)

    def data_label(self, addr: int) -> str:
        if addr in self.data_symbols:
            return f'{self.data_symbols[addr]}/{hex(addr)}'
        else:
            return hex(addr)

    def misc_label(self, n: int) -> str:
        return str(n)
        if n in self.other_symbols:
            return f'{self.other_symbols[n]}/{n}'
        else:
            return str(n)

    def addr(self, addr: int) -> str:
        if addr in self.text_symbols:
            return f'{self.text_symbols[addr]} ({hex(addr)})'
        elif addr in self.data_symbols:
            return f'{self.data_symbols[addr]} ({hex(addr)})'
        else:
            return hex(addr)

@dataclasses.dataclass
class Instruction:
    address: int
    instruction: int
    fields: list[str]
    execute: Callable[[Machine], None]
    static_target: Optional[int] = None
    return_target: Optional[int] = None
    label: Optional[str] = None
    is_target: bool = False
    arrows: Optional[list[tuple[bool, bool, int]]] = None

class Fault(Exception):
    def __init__(self, msg: str):
        self.msg = msg

@dataclasses.dataclass
class MemoryValue:
    address: int
    value: bytes
    signed: bool

@dataclasses.dataclass
class RegisterValue:
    register: int
    value: int

Value: TypeAlias = MemoryValue | RegisterValue

@dataclasses.dataclass
class Effects:
    # pc: old value, new value
    pc: tuple[int, int]
    reads: list[Value]
    writes: list[Value]
    undos: list[Value]
    stdin: Optional[bytes]
    stdout: Optional[bytes]
    other_message: Optional[str]
    terminate: bool
    function_start: Optional[int] # sp at call time
    function_end: Optional[int] # sp at ret time

def apply(m: Machine, e: Effects, is_forward: bool) -> None:
    m.set_pc(e.pc[0 if is_forward else 1])
    for w in (e.writes if is_forward else e.undos):
        match w:
            case RegisterValue(rd, val):
                m.set(rd, val)
            case MemoryValue(address, val, _):
                m.store(address, val)
    if e.stdout is not None:
        if is_forward:
            m.stdout += e.stdout
        else:
            m.stdout = m.stdout[:-len(e.stdout)]
    if e.stdin is not None:
        # echo input
        if is_forward:
            m.stdout += e.stdin
        else:
            m.stdout = m.stdout[:-len(e.stdin)]
    if e.function_start is not None:
        if is_forward:
            m.stack_frames.append(e.function_start)
        else:
            m.stack_frames.pop()
    if e.function_end is not None:
        if is_forward:
            m.stack_frames.pop()
        else:
            m.stack_frames.append(e.function_end)

def set_most_recent_memory(m: Machine, sequence: list[tuple[Instruction, Effects]], seq_i: int) -> None:
    m.most_recent_memory = m.data_start if m.data_start > 0 else m.stack_end-8
    m.most_recent_data = (m.data_start, 0)
    m.most_recent_stack = (m.stack_end-8, 0)
    (stack, data) = (False, False)
    for seq_i in range(seq_i, -1, -1):
        (instruction, e) = sequence[seq_i]
        for elt in itertools.chain(e.reads, e.writes):
            match elt:
                case MemoryValue(address, value, _):
                    if not stack and address >= m.stack_start:
                        m.most_recent_stack = (address, len(value))
                        if not data:
                            m.most_recent_memory = address
                        stack = True
                    if not data and address < m.data_end:
                        m.most_recent_data = (address, len(value))
                        if not stack:
                            m.most_recent_memory = address
                        data = True
                    if stack and data:
                        break

def report_effects(e: Effects) -> str:
    parts = []
    for elt in e.writes:
        match elt:
            case RegisterValue(rd, val):
                if r[rd] in ('ra', 'sp'):
                    parts.append(f'{r[rd]} <- {hex(val)}')
                else:
                    parts.append(f'{r[rd]} <- {val}')
    if e.pc[1] != e.pc[0] + 4:
        parts.append(f'pc <- {hex(e.pc[1])}')
    if e.other_message is not None:
        parts.append(e.other_message)
    return ', '.join(parts)

# misc helpers
def unsigned(i: int) -> int:
    return i&0xffffffffffffffff

def unsigned32(i: int) -> int:
    return i&0x00000000ffffffff

maxint = (1<<63) - 1
def old_clip(i: int) -> int:
    if -maxint - 1 <= i <= maxint:
        return i
    return (i + (maxint+1)) % (2 * (maxint+1)) - maxint - 1

maxint32 = (1<<31) - 1
def old_clip32(i: int) -> int:
    if -maxint32 - 1 <= i <= maxint32:
        return i
    return (i + (maxint32+1)) % (2 * (maxint32+1)) - maxint32 - 1

max64 = 1<<63
def clip(i: int) -> int:
    if -max64 <= i < max64:
        return i
    return ctypes.c_int64(i).value

max32 = 1<<31
def clip32(i: int) -> int:
    if -max32 <= i < max32:
        return i
    return ctypes.c_int32(i).value

def load_elf(filename: str) -> Machine:
    with open(filename, mode='rb') as fp:
        raw = fp.read()

        # unpack the elf header
        (
            e_ident_mag,
            e_ident_class, e_ident_data, e_ident_version, e_ident_osabi,
            e_ident_abiversion,

            e_type, e_machine, e_version, e_entry,

            e_phoff, e_shoff,

            e_flags, e_ehsize, e_phentsize, e_phnum, e_shentsize, e_shnum, e_shstrndx
        ) = struct.unpack('<4s5B7x'+'2HIQ'+'2Q'+'I6H', raw[:0x40])

        # sanity check everything
        assert(e_ident_mag == b'\x7fELF')       # magic number
        assert(e_ident_class == 2)              # 64 bit
        assert(e_ident_data == 1)               # little endian
        assert(e_ident_version == 1)            # version 1 format
        assert(e_ident_osabi == 0)              # System V ABI

        assert(e_type == 2)                     # executable
        assert(e_machine == 0xf3)               # RISC-V
        assert(e_version == 1)                  # ELF version 1

        assert(e_phoff == 0x40)                 # start of program headers
        assert(e_ehsize == 0x40)                # size of elf header
        assert(e_phentsize == 0x38)             # size of program header entry
        assert(e_phnum >= 1)                    # number of program header entries

        # first pass--find how big the VM footprint is
        memory_start, memory_end = 0, 0
        for i in range(e_phnum):
            # unpack the program header
            #print('unpacking program header')
            start = e_phoff + e_phentsize*i
            (
                p_type, p_flags, p_offset, p_vaddr, p_paddr, p_filesz, p_memsz, p_align
            ) = struct.unpack('<2I6Q', raw[start:start+e_phentsize])

            if p_type != 1:
                continue
            assert(p_vaddr >= 0)
            #print(f'found section at {p_vaddr} + {p_memsz}')
            if memory_end == 0 or p_vaddr < memory_start:
                memory_start = p_vaddr
            if p_vaddr + p_memsz > memory_end:
                memory_end = p_vaddr + p_memsz

        # get the section header strings
        i = e_shstrndx
        start = e_shoff + e_shentsize*i
        (
            sh_name, sh_type, sh_flags, sh_addr, sh_offset, sh_size,
            sh_link, sh_info, sh_addralign, sh_entsize
        ) = struct.unpack('<2I4Q2I2Q', raw[start:start+e_shentsize])

        # unpack the strings, keyed by offset
        sh_strs = {}
        sh_str_raw = raw[sh_offset:sh_offset + sh_size]
        start = 0
        for (i, b) in enumerate(sh_str_raw):
            if b == 0:
                sh_strs[start] = sh_str_raw[start:i].decode()
                start = i+1

        text_start, text_end = 0, 0
        data_start, data_end = 0, 0
        (strs_raw, syms_raw) = (b'', b'')
        seg_text, seg_data = -1, -1
        # read the section headers
        for i in range(e_shnum):
            # unpack the section header
            start = e_shoff + e_shentsize*i
            (
                sh_name, sh_type, sh_flags, sh_addr, sh_offset, sh_size,
                sh_link, sh_info, sh_addralign, sh_entsize
            ) = struct.unpack('<2I4Q2I2Q', raw[start:start+e_shentsize])

            #print(f'{i}: name: {sh_strs[sh_name]}. type: {hex(sh_type)}')
            if sh_strs[sh_name] == '.text' and sh_flags & 4 != 0 and sh_type == 1:
                assert(text_start == 0 and text_end == 0)
                seg_text = i
                text_start, text_end = sh_addr, sh_addr + sh_size

            elif sh_strs[sh_name] == '.data':
                seg_data = i
                data_start, data_end = sh_addr, sh_addr + sh_size

            elif sh_strs[sh_name] == '.strtab' and sh_type == 3:
                strs_raw = raw[sh_offset:sh_offset + sh_size]

            elif sh_strs[sh_name] == '.symtab' and sh_type == 2:
                syms_raw = raw[sh_offset:sh_offset + sh_size]

        assert(len(strs_raw) > 0)
        assert(len(syms_raw) > 0)
        assert(seg_text >= 0)

        # parse the symbol table
        text_symbols = {}
        data_symbols = {}
        other_symbols = {}
        global_pointer = 0
        symbol_size = 24
        for start in range(0, len(syms_raw), symbol_size):
            (
                st_name, st_info, st_other, st_shndx, st_value, st_size
            ) = struct.unpack('<I2BH2Q', syms_raw[start:start+symbol_size])

            # find the name
            for end in range(st_name, len(strs_raw)):
                if strs_raw[end] == 0:
                    break
            name = strs_raw[st_name:end].decode()
            if len(name) == 0:
                # skip section entries
                continue
            elif st_info == 4:
                # skip object file names
                continue
            elif name == '__global_pointer$':
                # keep global pointer
                global_pointer = st_value
                continue
            elif name.startswith('$') or name.startswith('__'):
                # skip internal names
                continue

            # sort into text, data, and other symbols
            if st_shndx == seg_text:
                text_symbols[st_value] = name
            elif st_shndx == seg_data and seg_data >= 0:
                data_symbols[st_value] = name
            else:
                other_symbols[st_value] = name


        # round to page boundaries at both ends
        memory_start &= ~4095
        memory_end = (memory_end + 4095) & ~4095

        assert(text_start != 0 and text_end != 0)
        assert(text_start <= e_entry < text_end)

        # allocate a page of stack
        #print(f'allocated {(memory_end - memory_start) // 1024}k address space from 0x{memory_start:x} to 0x{memory_end:x} (not including 4k stack)')

        # allocate address space
        m = Machine(memory_start, memory_end, e_entry, text_start, text_end, text_symbols, data_start, data_end, data_symbols, other_symbols, global_pointer)

        # second pass--load the segments
        for i in range(e_phnum):
            # unpack the program header
            #print(f'unpacking program header {i+1}')
            start = e_phoff + e_phentsize*i
            (
                p_type, p_flags, p_offset, p_vaddr, p_paddr, p_filesz, p_memsz, p_align
            ) = struct.unpack('<2I6Q', raw[start:start+e_phentsize])

            if p_type != 1:
                #print('    skipping non-loadable segment')
                continue
            #print(f'    loading segment from offset 0x{p_offset:x} with size 0x{p_filesz:x}')
            #print(f'    into virtual address 0x{p_vaddr:x} with size 0x{p_memsz:x}')

            for i in range(p_filesz):
                m.set_byte(p_vaddr + i, raw[p_offset + i])

        # m has been recording memory write effects, so reset it
        m.gather_effects()
        return m

# instruction decoders
def get_funct3(inst: int) -> int:
    return (inst>>12) & 0x07

def get_rd(inst: int) -> int:
    return (inst>>7) & 0x1f

def get_rs1(inst: int) -> int:
    return (inst>>15) & 0x1f

def get_rs2(inst: int) -> int:
    return (inst>>20) & 0x1f

def get_imm_i(inst: int) -> int:
    return inst >> 20

def get_imm_s(inst: int) -> int:
    imm =  (inst >> 20) & ~0x0000001f
    imm |= (inst >> 7)  &  0x0000001f
    return imm

def get_imm_b(inst: int) -> int:
    imm =  (inst >> 20) & ~0x00000fff
    imm |= (inst << 4)  &  0x00000800
    imm |= (inst >> 20) &  0x000007e0
    imm |= (inst >> 7)  &  0x0000001e
    return imm

def get_imm_u(inst: int) -> int:
    return inst & ~0x00000fff

def get_imm_j(inst: int) -> int:
    imm =  (inst >> 11) & ~0x000fffff
    imm |=  inst        &  0x000ff000
    imm |= (inst >> 9)  &  0x00000800
    imm |= (inst >> 20) &  0x000007e0
    imm |= (inst >> 20) &  0x0000001e
    return imm

def get_funct7(inst: int) -> int:
    return inst >> 25

r = [
    'zero', 'ra', 'sp', 'gp', 'tp', 't0', 't1', 't2',
    's0', 's1', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5',
    'a6', 'a7', 's2', 's3', 's4', 's5', 's6', 's7',
    's8', 's9', 's10', 's11', 't3', 't4', 't5', 't6',
]

def decode(labels: Machine, address: int, inst: int) -> Instruction:
    # divide the instructions up according the main instruction opcode
    # then call a specialized function for each opcode to do the rest
    opcode = inst & 0x7f
    match opcode:
        # lui
        case 0x37:
            return decode_lui(address, inst, get_rd(inst), get_imm_u(inst))

        # auipc
        case 0x17:
            return decode_auipc(address, inst, get_rd(inst), get_imm_u(inst))

        # jal
        case 0x6f:
            return decode_jal(labels, address, inst, get_rd(inst), get_imm_j(inst))

        # jalr
        case 0x67:
            return decode_jalr(address, inst, get_funct3(inst), get_rd(inst), get_rs1(inst), get_imm_i(inst))

        # beq, bne, blt, bge, bltu, bgeu
        case 0x63:
            return decode_branches(labels, address, inst, get_funct3(inst), get_rs1(inst), get_rs2(inst), get_imm_b(inst))

        # lb, lh, lw, ld, lbu, lhu, lwu
        case 0x03:
            return decode_load(address, inst, get_funct3(inst), get_rd(inst), get_rs1(inst), get_imm_i(inst))

        # sb, sh, sw, sd
        case 0x23:
            return decode_store(address, inst, get_funct3(inst), get_rs1(inst), get_rs2(inst), get_imm_s(inst))

        # addi, slti, sltiu, xori, ori, andi, slli, srli, srai
        case 0x13:
            return decode_alu_imm(labels, address, inst, get_funct3(inst), get_rd(inst), get_rs1(inst), get_imm_i(inst))

        # addiw, slliw, srliw, sraiw
        case 0x1b:
            return decode_alu_imm_w(labels, address, inst, get_funct3(inst), get_rd(inst), get_rs1(inst), get_imm_i(inst))

        # add, sub, sll, slt, sltu, xor, srl, sra, or, and
        # mul, mulh, mulhsu, mulhu, div, divu, rem, remu
        case 0x33:
            return decode_alu(address, inst, get_funct3(inst), get_rd(inst), get_rs1(inst), get_rs2(inst), get_funct7(inst))

        # addw, subw, sllw, srlw, sraw
        # mulw, divw, remw, remuw
        case 0x3b:
            return decode_alu_w(address, inst, get_funct3(inst), get_rd(inst), get_rs1(inst), get_rs2(inst), get_funct7(inst))

        # fence
        case 0x0f:
            def execute_fence(m: Machine) -> None:
                # do nothing
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['fence', '*'], execute_fence)

        # ecall, ebreak
        case 0x73:
            if inst == 0x00000073:
                return decode_ecall(address, inst)
            elif inst == 0x00100073:
                # handle ebreak here--exit
                def execute_ebreak(m: Machine) -> None:
                    m.other_message = 'ebreak'
                    m.terminate = True

                return Instruction(address, inst, ['ebreak'], execute_ebreak)

    raise Fault(f'disassembler found unknown opcode {opcode}')

def decode_lui(address: int, inst: int, rd: int, imm: int) -> Instruction:
    def execute_lui(m: Machine) -> None:
        m.set(rd, imm)
        m.set_pc(m.pc + 4)

    return Instruction(address, inst, ['lui', r[rd], str(imm)], execute_lui)

def decode_auipc(address: int, inst: int, rd: int, imm: int) -> Instruction:
    def execute_auipc(m: Machine) -> None:
        m.set(rd, m.pc + imm)
        m.set_pc(m.pc + 4)

    return Instruction(address, inst, ['auipc', r[rd], str(imm)], execute_auipc)

def decode_jal(labels: Machine, address: int, inst: int, rd: int, imm: int) -> Instruction:
    def execute_jal(m: Machine) -> None:
        m.set(rd, m.pc + 4)
        m.set_pc(m.pc + imm)
        if r[rd] == 'ra':
            m.mark_function_start()

    dest = labels.text_label(address+imm)
    if r[rd] == 'zero':
        fields = ['j', dest]
    elif r[rd] == 'ra':
        fields = ['call', dest]
    else:
        fields = ['jal', r[rd], dest]
    return Instruction(address, inst, fields, execute_jal,
        static_target=address + imm, return_target=None if rd == 0 else address + 4)

def decode_jalr(address: int, inst: int, funct3: int, rd: int, rs1: int, imm: int) -> Instruction:
    if funct3 != 0:
        raise Fault(f'jalr with unknown funct3 value of {funct3}')

    def execute_jalr(m: Machine) -> None:
        # rd and rs1 could be the same, so capture rs1 before setting rd
        rs1_val = m.get(rs1)
        m.set(rd, m.pc + 4)
        m.set_pc((rs1_val + imm) & ~1)
        if r[rd] == 'ra':
            m.mark_function_start()
        if r[rd] == 'zero' and imm == 0 and r[rs1] == 'ra':
            m.mark_function_end()

    match (r[rd], imm, r[rs1]):
        case ('zero', 0, 'ra'):
            fields = ['ret']
        case ('zero', 0, _):
            fields = ['jr', r[rs1]]
        case ('ra', 0, _):
            fields = ['jalr', r[rs1]]
        case (_, 0, _):
            fields = ['jalr', r[rd], f'({r[rs1]})']
        case _:
            fields = ['jalr', r[rd], f'{imm}({r[rs1]})']

    return Instruction(address, inst, fields, execute_jalr,
        return_target=None if rd == 0 else address + 4)

def decode_branches(labels: Machine, address: int, inst: int, funct3: int, rs1: int, rs2: int, imm: int) -> Instruction:
    match funct3:
        case 0:
            def execute_beq(m: Machine) -> None:
                if m.get(rs1) == m.get(rs2):
                    m.set_pc(m.pc + imm)
                else:
                    m.set_pc(m.pc + 4)

            dest = labels.text_label(address+imm, pc=address)
            if r[rs1] == 'zero':
                fields = ['beqz', r[rs2], dest]
            elif r[rs2] == 'zero':
                fields = ['beqz', r[rs1], dest]
            else:
                fields = ['beq', r[rs1], r[rs2], dest]

            return Instruction(address, inst, fields, execute_beq,
                static_target=address+imm)

        case 1:
            def execute_bne(m: Machine) -> None:
                if m.get(rs1) != m.get(rs2):
                    m.set_pc(m.pc + imm)
                else:
                    m.set_pc(m.pc + 4)

            dest = labels.text_label(address+imm, pc=address)
            if r[rs1] == 'zero':
                fields = ['bnez', r[rs2], dest]
            elif r[rs2] == 'zero':
                fields = ['bnez', r[rs1], dest]
            else:
                fields = ['bne', r[rs1], r[rs2], dest]
            return Instruction(address, inst, fields, execute_bne,
                static_target=address+imm)

        case 4:
            def execute_blt(m: Machine) -> None:
                if m.get(rs1) < m.get(rs2):
                    m.set_pc(m.pc + imm)
                else:
                    m.set_pc(m.pc + 4)

            dest = labels.text_label(address+imm, pc=address)
            if r[rs1] == 'zero':
                fields=['bgtz', r[rs2], dest]
            elif r[rs2] == 'zero':
                fields=['bltz', r[rs1], dest]
            else:
                fields=['blt', r[rs1], r[rs2], dest]

            return Instruction(address, inst, fields, execute_blt,
                static_target=address+imm)

        case 5:
            def execute_bge(m: Machine) -> None:
                if m.get(rs1) >= m.get(rs2):
                    m.set_pc(m.pc + imm)
                else:
                    m.set_pc(m.pc + 4)

            dest = labels.text_label(address+imm, pc=address)
            if r[rs1] == 'zero':
                fields=['blez', r[rs2], dest]
            elif r[rs2] == 'zero':
                fields=['bgez', r[rs1], dest]
            else:
                fields=['bge', r[rs1], r[rs2], dest]

            return Instruction(address, inst, fields, execute_bge,
                static_target=address+imm)

        case 6:
            def execute_bltu(m: Machine) -> None:
                if unsigned(m.get(rs1)) < unsigned(m.get(rs2)):
                    m.set_pc(m.pc + imm)
                else:
                    m.set_pc(m.pc + 4)

            dest = labels.text_label(address+imm, pc=address)

            return Instruction(address, inst, ['bltu', r[rs1], r[rs2], dest], execute_bltu,
                static_target=address+imm)

        case 7:
            def execute_bgeu(m: Machine) -> None:
                if unsigned(m.get(rs1)) >= unsigned(m.get(rs2)):
                    m.set_pc(m.pc + imm)
                else:
                    m.set_pc(m.pc + 4)

            dest = labels.text_label(address+imm, pc=address)

            return Instruction(address, inst, ['bgeu', r[rs1], r[rs2], dest], execute_bgeu,
                static_target=address+imm)

        case _:
            raise Fault(f'branch of unknown type {funct3}')

def decode_load(address: int, inst: int, funct3: int, rd: int, rs1: int, imm: int) -> Instruction:
    match funct3:
        case 0:
            def execute_lb(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.lb(effective_address))
                m.set_pc(m.pc + 4)

            fields=['lb', r[rd], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_lb)

        case 1:
            def execute_lh(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.lh(effective_address))
                m.set_pc(m.pc + 4)

            fields=['lh', r[rd], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_lh)

        case 2:
            def execute_lw(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.lw(effective_address))
                m.set_pc(m.pc + 4)

            fields=['lw', r[rd], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_lw)

        case 3:
            def execute_ld(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.ld(effective_address))
                m.set_pc(m.pc + 4)

            fields=['ld', r[rd], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_ld)

        case 4:
            def execute_lbu(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.lbu(effective_address))
                m.set_pc(m.pc + 4)

            fields=['lbu', r[rd], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_lbu)

        case 5:
            def execute_lhu(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.lhu(effective_address))
                m.set_pc(m.pc + 4)

            fields=['lhu', r[rd], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_lhu)

        case 6:
            def execute_lwu(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.lwu(effective_address))
                m.set_pc(m.pc + 4)

            fields=['lwu', r[rd], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_lwu)

    raise Fault(f'load instruction of unknown type {funct3}')

def decode_store(address: int, inst: int, funct3: int, rs1: int, rs2: int, imm: int) -> Instruction:
    match funct3:
        case 0:
            def execute_sb(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                val8 = m.get(rs2) & 0xff
                m.sb(effective_address, val8)
                m.set_pc(m.pc + 4)

            fields=['sb', r[rs2], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_sb)

        case 1:
            def execute_sh(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                val16 = m.get(rs2) & 0xffff
                m.sh(effective_address, val16)
                m.set_pc(m.pc + 4)

            fields=['sh', r[rs2], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_sh)

        case 2:
            def execute_sw(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                val32 = m.get(rs2) & 0xffffffff
                m.sw(effective_address, val32)
                m.set_pc(m.pc + 4)

            fields=['sw', r[rs2], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_sw)

        case 3:
            def execute_sd(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.sd(effective_address, m.get(rs2))
                m.set_pc(m.pc + 4)

            fields=['sd', r[rs2], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_sd)

    raise Fault(f'store instruction of unknown type {funct3}')

def decode_alu_imm(labels: Machine, address: int, inst: int, funct3: int, rd: int, rs1: int, imm: int) -> Instruction:
    shamt = imm & 0x3f
    imm_high = imm>>6

    match funct3:
        case 0:
            def execute_addi(m: Machine) -> None:
                m.set(rd, m.get(rs1) + imm)
                m.set_pc(m.pc + 4)

            match (r[rd], r[rs1], imm):
                case ('zero', 'zero', 0):
                    fields=['nop']
                case (_, 'zero', _):
                    fields=['li', r[rd], labels.misc_label(imm)]
                case (_, _, 0):
                    fields=['mv', r[rd], r[rs1]]
                case (_, 'gp', _) if r[rd] != 'gp':
                    fields=['la', r[rd], labels.data_label(labels.global_pointer + imm)]
                case _:
                    fields=['addi', r[rd], r[rs1], str(imm)]

            return Instruction(address, inst, fields, execute_addi)

        case 2:
            def execute_slti(m: Machine) -> None:
                m.set(rd, 1 if m.get(rs1) < imm else 0)
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['slti', r[rd], r[rs1], str(imm)], execute_slti)

        case 3:
            def execute_sltiu(m: Machine) -> None:
                m.set(rd, 1 if unsigned(m.get(rs1)) < unsigned(imm) else 0)
                m.set_pc(m.pc + 4)

            if imm == 1:
                fields=['seqz', r[rd], r[rs1]]
            else:
                fields=['sltiu', r[rd], r[rs1], str(imm)]

            return Instruction(address, inst, fields, execute_sltiu)

        case 4:
            def execute_xori(m: Machine) -> None:
                m.set(rd, m.get(rs1) ^ unsigned(imm))
                m.set_pc(m.pc + 4)

            if imm == -1:
                fields=['not', r[rd], r[rs1]]
            else:
                fields=['xori', r[rd], r[rs1], str(imm)]

            return Instruction(address, inst, fields, execute_xori)

        case 6:
            def execute_ori(m: Machine) -> None:
                m.set(rd, m.get(rs1) | imm)
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['ori', r[rd], r[rs1], str(imm)], execute_ori)

        case 7:
            def execute_andi(m: Machine) -> None:
                m.set(rd, m.get(rs1) & imm)
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['andi', r[rd], r[rs1], str(imm)], execute_andi)

        case 1:
            if imm_high != 0x00:
                raise Fault(f'immediate mode alu instruction of type {funct3} with unknown subtype {imm_high}')

            def execute_slli(m: Machine) -> None:
                m.set(rd, m.get(rs1) << shamt)
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['slli', r[rd], r[rs1], str(shamt)], execute_slli)

        case 5:
            if imm_high == 0x00:
                def execute_srli(m: Machine) -> None:
                    m.set(rd, unsigned(m.get(rs1)) >> shamt)
                    m.set_pc(m.pc + 4)

                return Instruction(address, inst, ['srli', r[rd], r[rs1], str(shamt)], execute_srli)

            elif imm_high == 0x10:
                def execute_srai(m: Machine) -> None:
                    m.set(rd, m.get(rs1) >> shamt)
                    m.set_pc(m.pc + 4)

                return Instruction(address, inst, ['srai', r[rd], r[rs1], str(shamt)], execute_srai)

            raise Fault(f'immediate mode alu instruction of type {funct3} with unknown subtype {imm_high}')

    raise Fault(f'immediate mode alu instruction of unknown type {funct3}')

def decode_alu_imm_w(labels: Machine, address: int, inst: int, funct3: int, rd: int, rs1: int, imm: int) -> Instruction:
    shamt = imm & 0x1f
    imm_high = imm>>5

    match funct3:
        case 0:
            def execute_addiw(m: Machine) -> None:
                m.set32(rd, m.get(rs1) + imm)
                m.set_pc(m.pc + 4)

            match (r[rd], r[rs1], imm):
                case ('zero', 'zero', 0):
                    fields=['nop']
                case (_, 'zero', _):
                    fields=['li', r[rd], labels.misc_label(imm)]
                case _:
                    fields=['addiw', r[rd], r[rs1], str(imm)]

            return Instruction(address, inst, fields, execute_addiw)

        case 1:
            if imm_high != 0x00:
                raise Fault(f'immediate mode alu w instruction of type {funct3} with unknown subtype {imm_high}')

            def execute_slliw(m: Machine) -> None:
                m.set32(rd, m.get(rs1) << shamt)
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['slliw', r[rd], r[rs1], str(shamt)], execute_slliw)

        case 5:
            if imm_high == 0x00:
                def execute_srliw(m: Machine) -> None:
                    m.set32(rd, unsigned32(m.get(rs1)) >> shamt)
                    m.set_pc(m.pc + 4)

                return Instruction(address, inst, ['srliw', r[rd], r[rs1], str(shamt)], execute_srliw)

            elif imm_high == 0x20:
                def execute_sraiw(m: Machine) -> None:
                    m.set32(rd, clip32(m.get(rs1)) >> shamt)
                    m.set_pc(m.pc + 4)

                return Instruction(address, inst, ['sraiw', r[rd], r[rs1], str(shamt)], execute_sraiw)

            raise Fault(f'immediate mode alu w instruction of type {funct3} with unknown subtype {imm_high}')

    raise Fault(f'immediate mode alu w instruction of unknown type {funct3}')

def decode_alu(address: int, inst: int, funct3: int, rd: int, rs1: int, rs2: int, funct7: int) -> Instruction:
    combined = (funct7 << 8) | funct3

    match combined:
        case 0x0000:
            def execute_add(m: Machine) -> None:
                m.set(rd, m.get(rs1) + m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['add', r[rd], r[rs1], r[rs2]], execute_add)

        case 0x2000:
            def execute_sub(m: Machine) -> None:
                m.set(rd, m.get(rs1) - m.get(rs2))
                m.set_pc(m.pc + 4)

            if r[rs1] == 'zero':
                fields=['neg', r[rd], r[rs2]]
            else:
                fields=['sub', r[rd], r[rs1], r[rs2]]

            return Instruction(address, inst, fields, execute_sub)

        case 0x0001:
            def execute_sll(m: Machine) -> None:
                m.set(rd, m.get(rs1) << (m.get(rs2) & 0x3f))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['sll', r[rd], r[rs1], r[rs2]], execute_sll)

        case 0x0002:
            def execute_slt(m: Machine) -> None:
                m.set(rd, 1 if m.get(rs1) < m.get(rs2) else 0)
                m.set_pc(m.pc + 4)

            if r[rs2] == 'zero':
                fields=['sltz', r[rd], r[rs1]]
            elif r[rs1] == 'zero':
                fields=['sgtz', r[rd], r[rs2]]
            else:
                fields=['slt', r[rd], r[rs1], r[rs2]]

            return Instruction(address, inst, fields, execute_slt)

        case 0x0003:
            def execute_sltu(m: Machine) -> None:
                m.set(rd, 1 if unsigned(m.get(rs1)) < unsigned(m.get(rs2)) else 0)
                m.set_pc(m.pc + 4)

            if r[rs1] == 'zero':
                fields=['snez', r[rd], r[rs2]]
            else:
                fields=['sltu', r[rd], r[rs1], r[rs2]]

            return Instruction(address, inst, fields, execute_sltu)

        case 0x0004:
            def execute_xor(m: Machine) -> None:
                m.set(rd, m.get(rs1) ^ m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['xor', r[rd], r[rs1], r[rs2]], execute_xor)

        case 0x0005:
            def execute_srl(m: Machine) -> None:
                m.set(rd, unsigned(m.get(rs1)) >> (m.get(rs2) & 0x3f))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['srl', r[rd], r[rs1], r[rs2]], execute_srl)

        case 0x2005:
            def execute_sra(m: Machine) -> None:
                m.set(rd, m.get(rs1) >> (m.get(rs2) & 0x3f))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['sra', r[rd], r[rs1], r[rs2]], execute_sra)

        case 0x0006:
            def execute_or(m: Machine) -> None:
                m.set(rd, m.get(rs1) | m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['or', r[rd], r[rs1], r[rs2]], execute_or)

        case 0x0007:
            def execute_and(m: Machine) -> None:
                m.set(rd, m.get(rs1) & m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['and', r[rd], r[rs1], r[rs2]], execute_and)

        case 0x0100:
            def execute_mul(m: Machine) -> None:
                m.set(rd, m.get(rs1) * m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['mul', r[rd], r[rs1], r[rs2]], execute_mul)

        case 0x0101:
            def execute_mulh(m: Machine) -> None:
                m.set(rd, (m.get(rs1) * m.get(rs2)) >> 64)
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['mulh', r[rd], r[rs1], r[rs2]], execute_mulh)

        case 0x0102:
            def execute_mulhsu(m: Machine) -> None:
                m.set(rd, (m.get(rs1) * unsigned(m.get(rs2))) >> 64)
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['mulhsu', r[rd], r[rs1], r[rs2]], execute_mulhsu)

        case 0x0103:
            def execute_mulhu(m: Machine) -> None:
                m.set(rd, (unsigned(m.get(rs1)) * unsigned(m.get(rs2))) >> 64)
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['mulhu', r[rd], r[rs1], r[rs2]], execute_mulhu)

        case 0x0104:
            def execute_div(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set(rd, -1)
                else:
                    m.set(rd, int(m.get(rs1) / m.get(rs2)))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['div', r[rd], r[rs1], r[rs2]], execute_div)

        case 0x0105:
            def execute_divu(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set(rd, -1)
                else:
                    m.set(rd, unsigned(m.get(rs1)) // unsigned(m.get(rs2)))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['divu', r[rd], r[rs1], r[rs2]], execute_divu)

        case 0x0106:
            def execute_rem(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set(rd, m.get(rs1))
                else:
                    m.set(rd, m.get(rs1) - int(m.get(rs1) / m.get(rs2)) * m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['rem', r[rd], r[rs1], r[rs2]], execute_rem)

        case 0x0107:
            def execute_remu(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set(rd, m.get(rs1))
                else:
                    m.set(rd, unsigned(m.get(rs1)) % unsigned(m.get(rs2)))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['remu', r[rd], r[rs1], r[rs2]], execute_remu)

    raise Fault(f'alu instruction of unknown type {funct3} subtype {funct7}')

def decode_alu_w(address: int, inst: int, funct3: int, rd: int, rs1: int, rs2: int, funct7: int) -> Instruction:
    combined = (funct7 << 8) | funct3

    match combined:
        case 0x0000:
            def execute_addw(m: Machine) -> None:
                m.set32(rd, m.get(rs1) + m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['addw', r[rd], r[rs1], r[rs2]], execute_addw)

        case 0x2000:
            def execute_subw(m: Machine) -> None:
                m.set32(rd, m.get(rs1) - m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['subw', r[rd], r[rs1], r[rs2]], execute_subw)

        case 0x0001:
            def execute_sllw(m: Machine) -> None:
                m.set32(rd, m.get(rs1) << (m.get(rs2) & 0x1f))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['sllw', r[rd], r[rs1], r[rs2]], execute_sllw)

        case 0x0005:
            def execute_srlw(m: Machine) -> None:
                m.set32(rd, unsigned32(m.get(rs1)) >> (m.get(rs2) & 0x1f))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['srlw', r[rd], r[rs1], r[rs2]], execute_srlw)

        case 0x2005:
            def execute_sraw(m: Machine) -> None:
                m.set32(rd, clip32(m.get(rs1)) >> (m.get(rs2) & 0x1f))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['sraw', r[rd], r[rs1], r[rs2]], execute_sraw)

        case 0x0100:
            def execute_mulw(m: Machine) -> None:
                m.set32(rd, m.get(rs1) * m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['mulw', r[rd], r[rs1], r[rs2]], execute_mulw)

        case 0x0104:
            def execute_divw(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set32(rd, -1)
                else:
                    m.set32(rd, int(m.get(rs1) / m.get(rs2)))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['divw', r[rd], r[rs1], r[rs2]], execute_divw)

        case 0x0105:
            def execute_divuw(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set32(rd, -1)
                else:
                    m.set32(rd, unsigned(m.get(rs1)) // unsigned(m.get(rs2)))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['divuw', r[rd], r[rs1], r[rs2]], execute_divuw)

        case 0x0106:
            def execute_remw(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set32(rd, m.get(rs1))
                else:
                    m.set32(rd, m.get(rs1) - int(m.get(rs1) / m.get(rs2)) * m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['remw', r[rd], r[rs1], r[rs2]], execute_remw)

        case 0x0107:
            def execute_remuw(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set32(rd, m.get(rs1))
                else:
                    m.set32(rd, unsigned(m.get(rs1)) % unsigned(m.get(rs2)))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['remuw', r[rd], r[rs1], r[rs2]], execute_remuw)

    raise Fault(f'alu w instruction of unknown type {funct3} subtype {funct7}')


def decode_ecall(address: int, inst: int) -> Instruction:
    def execute_ecall(m: Machine) -> None:
        if m.get(17) == 63:
            # read system call
            m.other_message = f'read({m.get(10)}, {hex(m.get(11))}, {m.get(12)})'
            if m.get(10) != 0:
                raise Fault(f'read syscall: only stdin (fd 0) supported, not {m.get(10)}')
            if m.get(12) < 0:
                raise Fault(f'read syscall: invalid buffer size: {m.get(12)}')

            read_res = sys.stdin.buffer.read(m.get(12))
            m.store(m.get(11), read_res)
            m.set(10, len(read_res))
            m.stdin_delta = read_res
            m.stdin += read_res
            m.set_pc(m.pc + 4)
            return

        if m.get(17) == 64:
            # write system call
            m.other_message = f'write({m.get(10)}, {hex(m.get(11))}, {m.get(12)})'
            if m.get(10) != 1:
                raise Fault(f'write syscall: only stdout (fd 1) supported, not {m.get(10)}')
            if m.get(12) < 0:
                raise Fault(f'write syscall: invalid buffer size: {m.get(12)}')

            buf = m.load(m.get(11), m.get(12))
            m.set(10, len(buf))
            m.stdout_delta = buf
            m.stdout += buf
            m.set_pc(m.pc + 4)
            return

        if m.get(17) == 93:
            # exit system call
            m.other_message = f'exit({m.get(10)})'
            m.terminate = True
            return

        # unimplemented
        raise Fault(f'unsupported syscall {m.get(17)}')

    return Instruction(address, inst, ['ecall'], execute_ecall)

def pair_instructions(m: Machine, instructions: dict[int, Instruction]) -> None:
    for pc in range(m.text_start, m.text_end, 4):
        instruction = instructions[pc]
        if pc+4 < m.text_end:
            instruction2 = instructions[pc+4]
            match (instruction, instruction2):
                case (Instruction(fields=['auipc', rd0, imm0]),
                      Instruction(fields=['addi', rd, rs1, imm])) if rd0 == rd and rs1 == rd:
                    addr = pc + int(imm0) + int(imm)
                    if m.text_start <= addr <= m.text_end:
                        sym = m.text_label(addr, pc=pc)
                    else:
                        sym = m.data_label(addr)
                    instruction.fields = ['auipc', rd0, imm0, f'[la {rd0}, {sym}]']

def add_labels(m: Machine, instructions: dict[int, Instruction]) -> None:
    # add labels from the symbol table and note branch targets
    for (pc, instruction) in instructions.items():
        if pc in m.text_symbols:
            instruction.label = m.text_symbols[pc]
        if instruction.static_target is not None:
            instructions[instruction.static_target].is_target = True

    # add numbered local labels
    next_label = 1
    next_fn = {}
    prev = -1
    for pc in range(m.text_start, m.text_end, 4):
        instruction = instructions[pc]
        if instruction.label is None and instruction.is_target:
            instruction.label = str(next_label)
            next_label += 1
        elif instruction.label is not None:
            next_label = 1
            if prev >= 0:
                next_fn[prev] = pc
            prev = pc
    if prev >= 0:
        next_fn[prev] = m.text_end

    # update branches to reference local labels
    fn_start = 0
    for pc in range(m.text_start, m.text_end, 4):
        instruction = instructions[pc]
        if instruction.label is not None and not instruction.label.isdigit():
            fn_start = pc
            fn_end = next_fn[fn_start]
        match instruction.fields:
            case ['j', dest]:
                pass
            case ['beqz', _, dest]:
                pass
            case ['beq', _, _, dest]:
                pass
            case ['bnez', _, dest]:
                pass
            case ['bne', _, _, dest]:
                pass
            case ['bgtz', _, dest]:
                pass
            case ['bltz', _, dest]:
                pass
            case ['blt', _, _, dest]:
                pass
            case ['blez', _, dest]:
                pass
            case ['bgez', _, dest]:
                pass
            case ['bge', _, _, dest]:
                pass
            case ['bltu', _, _, dest]:
                pass
            case ['bgeu', _, _, dest]:
                pass
            case _:
                continue
        if not dest.isdigit():
            continue

        # ignore branches outside the current function
        addr = int(dest)
        if addr < fn_start or addr >= fn_end:
            continue

        target_label = instructions[addr].label
        assert(target_label is not None)
        if target_label.isdigit():
            if addr < pc:
                instruction.fields[-1] = f'{target_label}b'
            elif addr > pc:
                instruction.fields[-1] = f'{target_label}f'

def pre_trace(m: Machine, instructions: dict[int, Instruction], echo_out: bool, echo_in: bool) -> list[tuple[Instruction, Effects]]:
    sequence = []
    while True:
        # fetch the next instruction
        instruction = instructions[m.pc]
        try:
            instruction.execute(m)
        except Fault as err:
            m.other_message = err.msg
            m.terminate = True
        e = m.gather_effects()
        sequence.append( (instruction, e) )
        if echo_out and e.stdout is not None:
            sys.stdout.buffer.write(e.stdout)
            sys.stdout.flush()
        if echo_in and e.stdin is not None and not sys.stdin.isatty():
            sys.stdout.buffer.write(e.stdin)
            sys.stdout.flush()
        if e.terminate:
            break

    # now rewind
    for (instruction, e) in reversed(sequence):
        apply(m, e, False)
    set_most_recent_memory(m, sequence, 0)

    return sequence

def find_function_bounds(m: Machine, pc: int) -> tuple[int, int]:
    assert(pc >= m.text_start and pc < m.text_end and pc%4 == 0)
    for start in range(pc, m.text_start-4, -4):
        if start in m.text_symbols:
            break
    for end in range(pc+4, m.text_end, 4):
        if end in m.text_symbols:
            break
    return (start, end)

def render_line(instruction: Instruction, effects: Optional[Effects]) -> list[str]:
    disasm = f'{instruction.fields[0]:<8}' + ', '.join(instruction.fields[1:])
    if instruction.label is None:
        addr_part = ''
    else:
        addr_part = instruction.label + ':'
    result = [f'{addr_part:<16}{disasm:<48}']
    if effects is None:
        return result

    result[0] += report_effects(effects)

    if effects.other_message is not None:
        result.append(f'{"":20}{effects.other_message}')
    if effects.stdin is not None:
        result.append(f'{"":20}{repr(effects.stdin.decode())}')
    if effects.stdout is not None:
        result.append(f'{"":20}{repr(effects.stdout.decode())}')

    return result

def calc_range(length: int, cursor: int, window_size: int) -> tuple[int, int]:
    half = (window_size - 1) // 2
    start = cursor - half
    end = start + window_size
    # shift up or down if it will fit more info
    if start < 0:
        shift = min(-start, max(0, length - end))
        start += shift
        end += shift
    if end > length:
        shift = min(end - length, max(0, start))
        start -= shift
        end -= shift
    return (start, end)

def ui(m: Machine, instructions: dict[int, Instruction], sequence: list[tuple[Instruction, Effects]]) -> None:
    # make sure stdin is connected to the tty
    if not sys.stdin.isatty():
        sys.stdin.close()
        os.close(0)
        sys.stdin = open('CON' if os.name == 'nt' else '/dev/tty', 'r')

    # take over terminal
    stdscr = curses.initscr()
    curses.noecho()
    curses.cbreak()
    stdscr.keypad(True)
    stdscr.clear()
    curses.curs_set(0)
    curses.start_color()
    curses.use_default_colors()
    if curses.COLORS < 256:
        print('This must be run in a terminal with support for at least 256 colors')
        sys.exit(1)

    # colors:
    # 0 = normal line (white on black, built-in)
    # 1 = current pc
    curses.init_pair(1, curses.COLOR_BLACK, 71)
    # 2 = cursor (if != pc)
    curses.init_pair(2, curses.COLOR_BLACK, 102)
    # 3 = current memory address
    curses.init_pair(3, curses.COLOR_WHITE, 17)
    # 10-16: memory, with pastel foreground colors
    curses.init_pair(10, 102, 16)
    curses.init_pair(11, 138, 16)
    curses.init_pair(12, 144, 16)
    curses.init_pair(13, 108, 16)
    curses.init_pair(14, 109, 16)
    curses.init_pair(15, 103, 16)
    curses.init_pair(16, 139, 16)
    data_color_pairs = [10, 11, 12, 13, 14, 15, 16]
    data_colors = list(zip(sorted(m.data_symbols.keys()), itertools.cycle(data_color_pairs)))

    # just in case there is no data segment
    if len(data_colors) == 0:
        data_colors.append((0, 0))

    # handle screen resizes
    (size_y, size_x) = (0, 0)
    active = True
    def resize() -> None:
        nonlocal stdscr, size_y, size_x, active
        (size_y, size_x) = stdscr.getmaxyx()
        if size_y < 3 or size_x < 5:
            active = False
            return
        active = True

    def addcolorstr(y: int, x: int, line: str, width: int) -> None:
        nonlocal stdscr
        i = 0
        color = 0
        while len(line) > 0 and i < width:
            if ord(line[0]) == 27:
                # escape followed by 2-digit decimal color pair number
                color = int(line[1:3])
                line = line[3:]
                continue
            j = 0
            while j < len(line) and i+j < width and ord(line[j]) != 27:
                j += 1
            chunk = line[:j]
            line = line[j:]
            stdscr.addstr(y, x+i, chunk, curses.color_pair(color))
            i += j

    (src_y, src_x) = (0, 0)
    seq_i = 0
    cursor_addr = sequence[seq_i][0].address
    pc = cursor_addr
    def draw() -> None:
        nonlocal stdscr, size_y, size_x, src_y, src_x, seq_i, cursor_addr, pc, m, data_colors
        if not active:
            return
        stdscr.erase()
        stdscr.box()

        # source view
        (src_top, src_y, src_x) = (1, size_y-2, size_x-2)

        # wide enough for memory view?
        (stack_left, stack_top, stack_y, stack_x) = (-1, 1, size_y-2, 40)
        (data_left, data_top, data_y, data_x) = (-1, 1, size_y-2, 40)
        if src_x >= 80:
            src_x -= data_x+1

            # stack, data, or both?
            if size_y >= 20:
                stack_left = src_x+2
                stack_y = (size_y - 3) // 3
                data_left = src_x+2
                data_top = stack_top + stack_y + 1
                data_y = size_y - stack_y - 3
            elif m.most_recent_memory >= m.stack_start:
                stack_left = src_x+2
            else:
                data_left = src_x+2

        # tall enough for register view?
        (reg_top, reg_y, reg_x) = (-1, 4, src_x)
        if src_y - (reg_y+1) >= 3:
            src_y -= reg_y+1
            reg_top = src_top + src_y + 1

        # tall enough for output view?
        (out_top, out_y, out_x) = (-1, 4, src_x)
        if src_y - (out_y+1) >= 3:
            src_y -= out_y+1
            reg_top -= out_y+1
            out_top = reg_top + reg_y + 1

        # source/text view
        status_line = ' Text '[:src_x-2]
        stdscr.addstr(src_top-1, 2, status_line)

        # draw arrows for taken branches
        # or targets of taken branches
        (arrow_top, arrow_top_addr) = ([], -1)
        (arrow_bottom, arrow_bottom_addr) = ([], -1)

        (instruction, effects) = sequence[seq_i]
        if      instruction.fields[-1][-1] in 'bf' and \
                instruction.static_target is not None and instruction.return_target is None and \
                effects.pc[1] == instruction.static_target and \
                effects.pc[0] != effects.pc[1] and \
                effects.pc[0] + 4 != effects.pc[1]:
            is_back = effects.pc[1] < effects.pc[0]
            (arrow_top, arrow_top_addr) = (
                [curses.ACS_ULCORNER, curses.ACS_HLINE, curses.ACS_HLINE],
                effects.pc[1] if is_back else effects.pc[0])
            (arrow_bottom, arrow_bottom_addr) = (
                [curses.ACS_LLCORNER, curses.ACS_HLINE, curses.ACS_HLINE],
                effects.pc[0] if is_back else effects.pc[1])

        (start, _) = calc_range(
            (m.text_end - m.text_start)//4,
            (cursor_addr - m.text_start)//4,
            src_y)
        for i in range(src_y):
            addr = m.text_start + (start + i)*4
            arrow = []
            if addr == arrow_top_addr:
                arrow = arrow_top
            elif addr == arrow_bottom_addr:
                arrow = arrow_bottom
            elif arrow_top_addr < addr < arrow_bottom_addr:
                arrow = [curses.ACS_VLINE]
            if addr == pc:
                (instruction, effects) = sequence[seq_i]
                lines = render_line(instruction, effects)
                color = curses.color_pair(1)
            elif addr in instructions:
                instruction = instructions[addr]
                lines = render_line(instruction, None)
                if addr == cursor_addr:
                    color = curses.color_pair(2)
                else:
                    color = curses.color_pair(0)
            else:
                lines = ['']
                color = curses.color_pair(0)
                
            stdscr.addstr(src_top+i, 1, lines[0][:src_x].ljust(src_x), color)
            for (j, ch) in enumerate(arrow):
                stdscr.addch(src_top+i, 1+12+j, ch, color)

        # memory view
        if stack_left >= 0 or data_left >= 0:
            stdscr.vline(1, max(data_left, stack_left)-1, curses.ACS_VLINE, size_y-2)
            stdscr.addch(0, max(data_left, stack_left)-1, curses.ACS_TTEE)
            stdscr.addch(size_y-1, max(data_left, stack_left)-1, curses.ACS_BTEE)
            if stack_left >= 0 and data_left >= 0:
                stdscr.hline(data_top-1, data_left, curses.ACS_HLINE, data_x)
                stdscr.addch(data_top-1, data_left - 1, curses.ACS_LTEE)
                stdscr.addch(data_top-1, data_left + data_x, curses.ACS_RTEE)
            if stack_left >= 0:
                status_line = ' Stack '[:stack_x-2]
                stdscr.addstr(stack_top-1, stack_left+1, status_line)
            if data_left >= 0:
                status_line = ' Data '[:data_x-2]
                stdscr.addstr(data_top-1, data_left+1, status_line)

            # add stack frame boundaries to the color list
            frames = m.stack_frames + [m.get(r.index('sp'))]
            if len(frames) > 1 and frames[-1] == frames[-2]:
                frames.pop()
            stack_colors = list(reversed(list(zip(frames, itertools.cycle(data_color_pairs)))))
            data_colors.extend(stack_colors)

            (left, top) = (0, 1)
            current_region = len(data_colors) - 1
            def memory_line() -> None:
                nonlocal current_region
                while current_region > 0 and data_colors[current_region][0] > addr:
                    current_region -= 1
                (addr_s, hex_s, ascii_s) = (f'{"":7}', '', '')
                color = 0
                for j in range(addr, addr+8):
                    if j >= m.data_start and j < m.data_end or j >= m.stack_start and j < m.stack_start+4096:
                        addr_s = f'{addr:06x}:'

                        # did we just hit a label?
                        if current_region+1 < len(data_colors) and data_colors[current_region+1][0] == j:
                            current_region += 1
                        next_color = data_colors[current_region][1]

                        (recent, size) = (m.most_recent_stack[0], m.most_recent_stack[1])
                        if recent <= j < recent + size:
                            next_color = 1
                        (recent, size) = (m.most_recent_data[0], m.most_recent_data[1])
                        if recent <= j < recent + size:
                            next_color = 1
                        
                        if color != next_color:
                            if color != 0:
                                hex_s += '\03300'
                            color = next_color
                            hex_s += f' \033{color:02}'
                            ascii_s += f'\033{color:02}'
                        elif j > addr:
                            hex_s += ' '
                        n = m.get_byte(j)
                        hex_s += f'{n:02x}'
                        if n >= ord(' ') and n <= ord('~'):
                            ascii_s += chr(n)
                        else:
                            ascii_s += '·'
                    else:
                        if color != 0:
                            color = 0
                            hex_s += '\03300'
                            ascii_s += '\03300'
                        hex_s += '   '
                        ascii_s += ' '
                if color != 0:
                    hex_s += '\03300'
                    ascii_s += '\03300'
                stdscr.addstr(top+i, left, addr_s, color)
                addcolorstr(top+i, left, f'{addr_s}{hex_s} {ascii_s}', data_x)

            if stack_left >= 0:
                left = stack_left
                top = stack_top
                current_region = len(data_colors) - 1
                (_, end) = calc_range(
                    (m.stack_end - m.stack_start)//8,
                    (m.most_recent_stack[0] - m.stack_start)//8,
                    stack_y)

                for i in range(stack_y):
                    addr = m.stack_start + (end - 1 - i)*8
                    memory_line()
            if data_left >= 0:
                left = data_left
                top = data_top
                current_region = len(data_colors) - 1
                (_, end) = calc_range(
                    (m.data_end - m.data_start)//8,
                    (m.most_recent_data[0] - m.data_start)//8,
                    data_y)
                for i in range(data_y):
                    addr = m.data_start + (end - 1 - i)*8
                    memory_line()

            # clear the stack frame colors
            del data_colors[len(data_colors) - len(stack_colors):]

        # register view
        if reg_top >= 0:
            stdscr.hline(reg_top-1, 1, curses.ACS_HLINE, reg_x)
            stdscr.addch(reg_top-1, 0, curses.ACS_LTEE)
            stdscr.addch(reg_top-1, reg_x+1, curses.ACS_PLUS if reg_top == data_top else curses.ACS_RTEE)
            status_line = ' Registers '[:reg_x-2]
            stdscr.addstr(reg_top-1, 2, status_line)

            lines = [
                ' '.join([f'{x}:{m.get(r.index(x)):x}'
                    for x in ('ra', 'sp', 'gp', 'tp')]),
                ' '.join([f'{x}:{m.get(r.index(x)):x}'
                    for x in ('a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7')]),
                ' '.join([f'{x}:{m.get(r.index(x)):x}'
                    for x in ('t0', 't1', 't2', 't3', 't4', 't5', 't6')]),
                ' '.join([f'{x}:{m.get(r.index(x)):x}'
                    for x in ('s0', 's1', 's2', 's3', 's4', 's5', 's6', 's7', 's8', 's9', 's10', 's11')]),
            ]
            for (i, line) in enumerate(lines):
                stdscr.addstr(reg_top+i, 1, line[:reg_x])

        # output view
        if out_top >= 0:
            stdscr.hline(out_top-1, 1, curses.ACS_HLINE, out_x)
            stdscr.addch(out_top-1, 0, curses.ACS_LTEE)
            stdscr.addch(out_top-1, out_x+1, curses.ACS_PLUS if out_top == data_top else curses.ACS_RTEE)
            status_line = ' Output '[:out_x-2]
            stdscr.addstr(out_top-1, 2, status_line)

            lines = m.stdout.decode().splitlines()[-out_y:]
            for (i, line) in enumerate(lines):
                stdscr.addstr(out_top+i, 1, line[:reg_x])

        status_line = f' Step {seq_i+1}/{len(sequence)} PC:{pc:x} '[:size_x-4]
        stdscr.addstr(size_y-1, 2, status_line)
        stdscr.refresh()
        m.gather_effects()

    resize()
    draw()

    first = True
    block = True
    while True:
        stdscr.nodelay(not block)
        key = stdscr.getch()
        if key == curses.KEY_RIGHT and seq_i+1 < len(sequence):
            apply(m, sequence[seq_i][1], True)
            seq_i += 1
            set_most_recent_memory(m, sequence, seq_i)
            pc = sequence[seq_i][0].address
            cursor_addr = pc
        elif key == curses.KEY_LEFT and seq_i > 0:
            seq_i -= 1
            apply(m, sequence[seq_i][1], False)
            set_most_recent_memory(m, sequence, seq_i)
            pc = sequence[seq_i][0].address
            cursor_addr = pc
        elif key == curses.KEY_UP and cursor_addr-4 >= m.text_start:
            cursor_addr -= 4
        elif key == curses.KEY_DOWN and cursor_addr+4 < m.text_end:
            cursor_addr += 4
        elif key == curses.KEY_PPAGE and cursor_addr-4 >= m.text_start:
            cursor_addr -= 4*src_y
            if cursor_addr < m.text_start:
                cursor_addr = m.text_start
        elif key == curses.KEY_NPAGE and cursor_addr+4 < m.text_end:
            cursor_addr += 4*src_y
            if cursor_addr >= m.text_end:
                cursor_addr = m.text_end-4
        elif key in (curses.KEY_ENTER, ord('\n')):
            # find the next time the pc reaches this address
            for peek in range(seq_i+1, len(sequence)):
                if sequence[peek][0].address == cursor_addr:
                    # play the sequence forward to this point
                    for seq_i in range(seq_i, peek):
                        apply(m, sequence[seq_i][1], True)
                    seq_i += 1
                    set_most_recent_memory(m, sequence, seq_i)
                    pc = sequence[seq_i][0].address
                    cursor_addr = pc
                    break
        elif key in (curses.KEY_BACKSPACE , ord('\b'), ord('\x7f')):
            # find the previous time the pc was at this address
            for peek in range(seq_i-1, -1, -1):
                if sequence[peek][0].address == cursor_addr:
                    # play the sequence backward to this point
                    for seq_i in range(seq_i-1, peek-1, -1):
                        apply(m, sequence[seq_i][1], False)
                    set_most_recent_memory(m, sequence, seq_i)
                    pc = sequence[seq_i][0].address
                    cursor_addr = pc
                    break
        elif key == curses.KEY_HOME:
            # jump back to when current function was called
            (func_start, func_end) = find_function_bounds(m, pc)

            first = True
            for seq_i in range(seq_i, -1, -1):
                pc = sequence[seq_i][0].address
                cursor_addr = pc
                if first:
                    first = False
                else:
                    apply(m, sequence[seq_i][1], False)
                if func_start <= pc < func_end and (seq_i == 0 or sequence[seq_i-1][0].fields[0] == 'call'):
                    break
            set_most_recent_memory(m, sequence, seq_i)
        elif key == curses.KEY_END:
            # find the next return (or end of program) from current function
            (func_start, func_end) = find_function_bounds(m, pc)
            for seq_i in range(seq_i, len(sequence)):
                pc = sequence[seq_i][0].address
                cursor_addr = pc
                if func_start <= pc < func_end and sequence[seq_i][0].fields[0] == 'ret':
                    break
                apply(m, sequence[seq_i][1], True)
            set_most_recent_memory(m, sequence, seq_i)

        elif key == curses.KEY_RESIZE:
            resize()

        elif key == ord('q'):
            break

        if key == -1:
            draw()
            if first:
                draw()
                first = False
        block = key == -1

    # restore terminal
    curses.nocbreak()
    stdscr.keypad(False)
    curses.echo()
    curses.endwin()

def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument('-m', '--mode',
        choices=['run', 'trace', 'dasm', 'debug'],
        default='debug')
    parser.add_argument('-e', '--executable',
        default='a.out')
    args = parser.parse_args()

    # load the program from disk and form the
    # simulated address space and cpu
    m = load_elf(args.executable)

    # disassemble the entire text segment
    instructions = {}
    for pc in range(m.text_start, m.text_end, 4):
        inst = m.load_instruction(pc)
        instruction = decode(m, pc, inst)
        instructions[pc] = instruction
    pair_instructions(m, instructions)

    add_labels(m, instructions)

    if args.mode == 'dasm':
        for pc in range(m.text_start, m.text_end, 4):
            instruction = instructions[pc]
            disasm = f'{instruction.fields[0]:<8}' + ', '.join(instruction.fields[1:])
            if instruction.label is None:
                addr_part = ''
            else:
                addr_part = instruction.label + ':'
            line = f'{addr_part:<20}{disasm:<48}'
            print(line)
        return

    # trace the entire execution
    # for run mode, have pre_trace echo output as it goes
    # so inputs and outputs are correctly interleved
    sequence = pre_trace(m, instructions, args.mode in ('run', 'debug'), args.mode == 'debug')

    if args.mode == 'trace':
        for (instruction, effects) in sequence:
            for line in render_line(instruction, effects):
                print(line)

    if args.mode == 'debug':
        ui(m, instructions, sequence)

    # should have ended with exit(0)
    (instruction, effects) = sequence[-1]
    if instruction.fields[0] == 'ecall' and effects.other_message is not None:
        parts = re.match(r'exit\((\d+)\)', effects.other_message)
        if parts is not None:
            sys.exit(int(parts[1]))
    print(effects.other_message, file=sys.stderr)
    sys.exit(1)

main()
