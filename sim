#!/usr/bin/env python3

import argparse
import ctypes
import curses
import dataclasses
import re
import sys
import struct
from typing import Callable, Optional, TypeAlias

MISALIGNED_OKAY = True

class Machine:
    def __init__(self, memory_start: int, memory_end: int, pc_start: int, text_start: int, text_end: int, text_symbols: dict[int, str], data_symbols: dict[int, str], other_symbols: dict[int, str], global_pointer: int) -> None:
        # allocate memory
        assert(memory_start >= 4096)
        assert(memory_end > memory_start)
        assert(memory_start & 0xfff == 0)
        assert(memory_end & 0xfff == 0)
        self.memory = bytearray(memory_end - memory_start)
        self.memory_start = memory_start
        self.memory_end = memory_end
        self.pc_start = pc_start
        self.text_start = text_start
        self.text_end = text_end
        self.text_symbols = text_symbols
        self.data_symbols = data_symbols
        self.other_symbols = other_symbols
        self.global_pointer = global_pointer
        self.stdout = bytearray()
        self.stdin = bytearray()

        # allocate a stack with a guard page
        self.stack = bytearray(4096)
        self.stack_start = 0x10000000 - 4096
        if self.stack_start < memory_end + 4096:
            self.stack_start = memory_end + 4096
        self.stack_end = self.stack_start + 4096

        # set up cpu state
        self.x = [0] * 32
        self.pc = pc_start
        self.x[2] = self.stack_end

        # set up tracing
        self.old_pc = 0
        self.reads: list[Value] = []
        self.writes: list[Value] = []
        self.undos: list[Value] = []
        self.stdin_delta: Optional[bytes] = None
        self.stdout_delta: Optional[bytes] = None
        self.other_message: Optional[str] = None
        self.terminate = False

    def lb(self, addr: int) -> int:
        if      not (addr >= self.memory_start and addr < self.memory_end) and \
                not (addr >= self.stack_start  and addr < self.stack_end):
            raise Fault(f'Segmentation fault in lb: address is {addr}')
        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+1 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+1 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, True))
        return int.from_bytes(raw, byteorder='little', signed=True)

    def lh(self, addr: int) -> int:
        if not MISALIGNED_OKAY and (addr & 1) != 0:
            raise Fault(f'Bus error in lh: address is {addr}')
        if      not (addr >= self.memory_start and addr+1 < self.memory_end) and \
                not (addr >= self.stack_start  and addr+1 < self.stack_end):
            raise Fault(f'Segmentation fault in lh: address is {addr}')

        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+2 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+2 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, True))
        return int.from_bytes(raw, byteorder='little', signed=True)

    def lw(self, addr: int) -> int:
        if not MISALIGNED_OKAY and (addr & 3) != 0:
            raise Fault(f'Bus error in lw: address is {addr}')
        if      not (addr >= self.memory_start and addr+3 < self.memory_end) and \
                not (addr >= self.stack_start  and addr+3 < self.stack_end):
            raise Fault(f'Segmentation fault in lw: address is {addr}')

        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+4 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+4 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, True))
        return int.from_bytes(raw, byteorder='little', signed=True)

    def ld(self, addr: int) -> int:
        if not MISALIGNED_OKAY and (addr & 7) != 0:
            raise Fault(f'Bus error in ld: address is {addr}')
        if      not (addr >= self.memory_start and addr+7 < self.memory_end) and \
                not (addr >= self.stack_start  and addr+7 < self.stack_end):
            raise Fault(f'Segmentation fault in ld: address is {addr}')

        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+8 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+8 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, True))
        return int.from_bytes(raw, byteorder='little', signed=True)

    def lbu(self, addr: int) -> int:
        if      not (addr >= self.memory_start and addr < self.memory_end) and \
                not (addr >= self.stack_start  and addr < self.stack_end):
            raise Fault(f'Segmentation fault in lbu: address is {addr}')

        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+1 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+1 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, False))
        return int.from_bytes(raw, byteorder='little', signed=False)

    def lhu(self, addr: int) -> int:
        if not MISALIGNED_OKAY and (addr & 1) != 0:
            raise Fault(f'Bus error in lhu: address is {addr}')
        if      not (addr >= self.memory_start and addr+1 < self.memory_end) and \
                not (addr >= self.stack_start  and addr+1 < self.stack_end):
            raise Fault(f'Segmentation fault in lhu: address is {addr}')

        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+2 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+2 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, False))
        return int.from_bytes(raw, byteorder='little', signed=False)

    def lwu(self, addr: int) -> int:
        if not MISALIGNED_OKAY and (addr & 3) != 0:
            raise Fault(f'Bus error in lwu: address is {addr}')
        if      not (addr >= self.memory_start and addr+3 < self.memory_end) and \
                not (addr >= self.stack_start  and addr+3 < self.stack_end):
            raise Fault(f'Segmentation fault in lwu: address is {addr}')

        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+4 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+4 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, False))
        return int.from_bytes(raw, byteorder='little', signed=False)

    def sb(self, addr: int, value: int) -> None:
        if      not (addr >= self.memory_start and addr < self.memory_end) and \
                not (addr >= self.stack_start  and addr < self.stack_end):
            raise Fault(f'Segmentation fault in sb: address is {addr}')

        raw = ctypes.c_int8(value).value.to_bytes(1, byteorder='little', signed=True)
        if addr < self.memory_end:
            old = self.memory[addr - self.memory_start: addr+1 - self.memory_start]
            for (i, b) in enumerate(raw):
                self.memory[addr+i - self.memory_start] = b
        else:
            old = self.stack[addr - self.stack_start: addr+1 - self.stack_start]
            for (i, b) in enumerate(raw):
                self.stack[addr+i - self.stack_start] = b

        self.writes.append(MemoryValue(addr, raw, True))
        self.undos.append(MemoryValue(addr, old, True))

    def sh(self, addr: int, value: int) -> None:
        if not MISALIGNED_OKAY and (addr & 1) != 0:
            raise Fault(f'Bus error in sh: address is {addr}')
        if      not (addr >= self.memory_start and addr+1 < self.memory_end) and \
                not (addr >= self.stack_start  and addr+1 < self.stack_end):
            raise Fault(f'Segmentation fault in sh: address is {addr}')

        raw = ctypes.c_int16(value).value.to_bytes(2, byteorder='little', signed=True)
        if addr < self.memory_end:
            old = self.memory[addr - self.memory_start: addr+2 - self.memory_start]
            for (i, b) in enumerate(raw):
                self.memory[addr+i - self.memory_start] = b
        else:
            old = self.stack[addr - self.stack_start: addr+2 - self.stack_start]
            for (i, b) in enumerate(raw):
                self.stack[addr+i - self.stack_start] = b

        self.writes.append(MemoryValue(addr, raw, True))
        self.undos.append(MemoryValue(addr, old, True))

    def sw(self, addr: int, value: int) -> None:
        if not MISALIGNED_OKAY and (addr & 3) != 0:
            raise Fault(f'Bus error in sw: address is {addr}')
        if      not (addr >= self.memory_start and addr+3 < self.memory_end) and \
                not (addr >= self.stack_start  and addr+3 < self.stack_end):
            raise Fault(f'Segmentation fault in sw: address is {addr}')

        raw = ctypes.c_int32(value).value.to_bytes(4, byteorder='little', signed=True)
        if addr < self.memory_end:
            old = self.memory[addr - self.memory_start: addr+4 - self.memory_start]
            for (i, b) in enumerate(raw):
                self.memory[addr+i - self.memory_start] = b
        else:
            old = self.stack[addr - self.stack_start: addr+4 - self.stack_start]
            for (i, b) in enumerate(raw):
                self.stack[addr+i - self.stack_start] = b

        self.writes.append(MemoryValue(addr, raw, True))
        self.undos.append(MemoryValue(addr, old, True))

    def sd(self, addr: int, value: int) -> None:
        if not MISALIGNED_OKAY and (addr & 7) != 0:
            raise Fault(f'Bus error in sd: address is {addr}')
        if      not (addr >= self.memory_start and addr+7 < self.memory_end) and \
                not (addr >= self.stack_start  and addr+7 < self.stack_end):
            raise Fault(f'Segmentation fault in sd: address is {addr}')

        raw = ctypes.c_int64(value).value.to_bytes(8, byteorder='little', signed=True)
        if addr < self.memory_end:
            old = self.memory[addr - self.memory_start: addr+8 - self.memory_start]
            for (i, b) in enumerate(raw):
                self.memory[addr+i - self.memory_start] = b
        else:
            old = self.stack[addr - self.stack_start: addr+8 - self.stack_start]
            for (i, b) in enumerate(raw):
                self.stack[addr+i - self.stack_start] = b

        self.writes.append(MemoryValue(addr, raw, True))
        self.undos.append(MemoryValue(addr, old, True))

    def load_instruction(self, addr: int) -> int:
        if not MISALIGNED_OKAY and (addr & 3) != 0:
            raise Fault(f'Bus error in load_instruction: address is {addr}')
        if not (addr >= self.memory_start and addr+3 < self.memory_end):
            raise Fault(f'Segmentation fault in load_instruction: address is {addr}')

        raw = self.memory[addr - self.memory_start: addr+4 - self.memory_start]
        return int.from_bytes(raw, byteorder='little', signed=True)

    def get(self, reg: int) -> int:
        if reg != 0:
            self.reads.append(RegisterValue(reg, self.x[reg]))
        return self.x[reg]

    def set(self, reg: int, value: int) -> None:
        # zero register never changes
        if reg != 0:
            self.writes.append(RegisterValue(reg, clip(value)))
            self.undos.append(RegisterValue(reg, self.x[reg]))
            self.x[reg] = clip(value)

    def set32(self, reg: int, value: int) -> None:
        # zero register never changes
        if reg != 0:
            self.writes.append(RegisterValue(reg, clip32(value)))
            self.undos.append(RegisterValue(reg, self.x[reg]))
            self.x[reg] = clip32(value)

    def set_pc(self, value: int) -> None:
        self.old_pc = self.pc
        self.pc = clip(value)
        if self.pc & 3 != 0:
            raise Fault(f'Bus error: pc is {self.pc}')

    def gather_effects(self) -> 'Effects':
        e = Effects((self.old_pc, self.pc),
            self.reads, self.writes, self.undos,
            self.stdin_delta, self.stdout_delta,
            self.other_message, self.terminate)
        self.reads = []
        self.writes = []
        self.undos = []
        self.stdin_delta = None
        self.stdout_delta = None
        self.other_message = None
        self.terminate = False
        return e

    def text_label(self, addr: int, pc: int = 0) -> str:
        if addr in self.text_symbols:
            return f'{self.text_symbols[addr]}/{hex(addr)}'
        else:
            return str(addr)

    def data_label(self, addr: int) -> str:
        if addr in self.data_symbols:
            return f'{self.data_symbols[addr]}/{hex(addr)}'
        else:
            return hex(addr)

    def misc_label(self, n: int) -> str:
        if n in self.other_symbols:
            return f'{self.other_symbols[n]}/{n}'
        else:
            return str(n)

    def addr(self, addr: int) -> str:
        if addr in self.text_symbols:
            return f'{self.text_symbols[addr]} ({hex(addr)})'
        elif addr in self.data_symbols:
            return f'{self.data_symbols[addr]} ({hex(addr)})'
        else:
            return hex(addr)

@dataclasses.dataclass
class Instruction:
    address: int
    instruction: int
    fields: list[str]
    execute: Callable[[Machine], None]
    static_target: Optional[int] = None
    return_target: Optional[int] = None
    fallthrough: bool = True
    label: Optional[str] = None
    is_target: bool = False

class Fault(Exception):
    def __init__(self, msg: str):
        self.msg = msg

@dataclasses.dataclass
class MemoryValue:
    address: int
    value: bytes
    signed: bool

@dataclasses.dataclass
class RegisterValue:
    register: int
    value: int

Value: TypeAlias = MemoryValue | RegisterValue

@dataclasses.dataclass
class Effects:
    # pc: old value, new value
    pc: tuple[int, int]
    reads: list[Value]
    writes: list[Value]
    undos: list[Value]
    stdin: Optional[bytes]
    stdout: Optional[bytes]
    other_message: Optional[str]
    terminate: bool

def apply(m: Machine, e: Effects, is_forward: bool) -> None:
    m.set_pc(e.pc[0 if is_forward else 1])
    for w in (e.writes if is_forward else e.undos):
        match w:
            case RegisterValue(rd, val):
                m.set(rd, val)
            case MemoryValue(address, val, signed):
                as_int = int.from_bytes(val, byteorder='little', signed=signed)
                if len(val) == 1:
                    m.sb(address, as_int)
                elif len(val) == 2:
                    m.sh(address, as_int)
                elif len(val) == 4:
                    m.sw(address, as_int)
                elif len(val) == 8:
                    m.sd(address, as_int)
                else:
                    assert(False)

def report_effects(e: Effects) -> str:
    parts = []
    for elt in e.writes:
        match elt:
            case RegisterValue(rd, val):
                if r[rd] in ('ra', 'sp'):
                    parts.append(f'{r[rd]} <- {hex(val)}')
                else:
                    parts.append(f'{r[rd]} <- {val}')
    for elt in e.reads:
        match elt:
            case RegisterValue(rs, val):
                pass
    if e.pc[1] != e.pc[0] + 4:
        parts.append(f'pc <- {hex(e.pc[1])}')
    return ', '.join(parts)

# misc helpers
def unsigned(i: int) -> int:
    return i&0xffffffffffffffff

def unsigned32(i: int) -> int:
    return i&0x00000000ffffffff

maxint = (1<<63) - 1
def old_clip(i: int) -> int:
    if -maxint - 1 <= i <= maxint:
        return i
    return (i + (maxint+1)) % (2 * (maxint+1)) - maxint - 1

maxint32 = (1<<31) - 1
def old_clip32(i: int) -> int:
    if -maxint32 - 1 <= i <= maxint32:
        return i
    return (i + (maxint32+1)) % (2 * (maxint32+1)) - maxint32 - 1

max64 = 1<<63
def clip(i: int) -> int:
    if -max64 <= i < max64:
        return i
    return ctypes.c_int64(i).value

max32 = 1<<31
def clip32(i: int) -> int:
    if -max32 <= i < max32:
        return i
    return ctypes.c_int32(i).value

def load_elf(filename: str) -> Machine:
    with open(filename, mode='rb') as fp:
        raw = fp.read()

        # unpack the elf header
        (
            e_ident_mag,
            e_ident_class, e_ident_data, e_ident_version, e_ident_osabi,
            e_ident_abiversion,

            e_type, e_machine, e_version, e_entry,

            e_phoff, e_shoff,

            e_flags, e_ehsize, e_phentsize, e_phnum, e_shentsize, e_shnum, e_shstrndx
        ) = struct.unpack('<4s5B7x'+'2HIQ'+'2Q'+'I6H', raw[:0x40])

        # sanity check everything
        assert(e_ident_mag == b'\x7fELF')       # magic number
        assert(e_ident_class == 2)              # 64 bit
        assert(e_ident_data == 1)               # little endian
        assert(e_ident_version == 1)            # version 1 format
        assert(e_ident_osabi == 0)              # System V ABI

        assert(e_type == 2)                     # executable
        assert(e_machine == 0xf3)               # RISC-V
        assert(e_version == 1)                  # ELF version 1

        assert(e_phoff == 0x40)                 # start of program headers
        assert(e_ehsize == 0x40)                # size of elf header
        assert(e_phentsize == 0x38)             # size of program header entry
        assert(e_phnum >= 1)                    # number of program header entries

        # first pass--find how big the VM footprint is
        memory_start, memory_end = 0, 0
        for i in range(e_phnum):
            # unpack the program header
            #print('unpacking program header')
            start = e_phoff + e_phentsize*i
            (
                p_type, p_flags, p_offset, p_vaddr, p_paddr, p_filesz, p_memsz, p_align
            ) = struct.unpack('<2I6Q', raw[start:start+e_phentsize])

            if p_type != 1:
                continue
            assert(p_vaddr >= 0)
            #print(f'found section at {p_vaddr} + {p_memsz}')
            if memory_end == 0 or p_vaddr < memory_start:
                memory_start = p_vaddr
            if p_vaddr + p_memsz > memory_end:
                memory_end = p_vaddr + p_memsz

        # get the section header strings
        i = e_shstrndx
        start = e_shoff + e_shentsize*i
        (
            sh_name, sh_type, sh_flags, sh_addr, sh_offset, sh_size,
            sh_link, sh_info, sh_addralign, sh_entsize
        ) = struct.unpack('<2I4Q2I2Q', raw[start:start+e_shentsize])

        # unpack the strings, keyed by offset
        sh_strs = {}
        sh_str_raw = raw[sh_offset:sh_offset + sh_size]
        start = 0
        for (i, b) in enumerate(sh_str_raw):
            if b == 0:
                sh_strs[start] = sh_str_raw[start:i].decode()
                start = i+1

        text_start, text_end = 0, 0
        (strs_raw, syms_raw) = (b'', b'')
        seg_text, seg_data = -1, -1
        # read the section headers
        for i in range(e_shnum):
            # unpack the section header
            start = e_shoff + e_shentsize*i
            (
                sh_name, sh_type, sh_flags, sh_addr, sh_offset, sh_size,
                sh_link, sh_info, sh_addralign, sh_entsize
            ) = struct.unpack('<2I4Q2I2Q', raw[start:start+e_shentsize])

            #print(f'{i}: name: {sh_strs[sh_name]}. type: {hex(sh_type)}')
            if sh_strs[sh_name] == '.text' and sh_flags & 4 != 0 and sh_type == 1:
                assert(text_start == 0 and text_end == 0)
                seg_text = i
                text_start, text_end = sh_addr, sh_addr + sh_size

            elif sh_strs[sh_name] == '.data':
                seg_data = i

            elif sh_strs[sh_name] == '.strtab' and sh_type == 3:
                strs_raw = raw[sh_offset:sh_offset + sh_size]

            elif sh_strs[sh_name] == '.symtab' and sh_type == 2:
                syms_raw = raw[sh_offset:sh_offset + sh_size]

        assert(len(strs_raw) > 0)
        assert(len(syms_raw) > 0)
        assert(seg_text >= 0)

        # parse the symbol table
        text_symbols = {}
        data_symbols = {}
        other_symbols = {}
        global_pointer = 0
        symbol_size = 24
        for start in range(0, len(syms_raw), symbol_size):
            (
                st_name, st_info, st_other, st_shndx, st_value, st_size
            ) = struct.unpack('<I2BH2Q', syms_raw[start:start+symbol_size])

            # find the name
            for end in range(st_name, len(strs_raw)):
                if strs_raw[end] == 0:
                    break
            name = strs_raw[st_name:end].decode()
            if len(name) == 0:
                # skip section entries
                continue
            elif st_info == 4:
                # skip object file names
                continue
            elif name == '__global_pointer$':
                # keep global pointer
                global_pointer = st_value
                continue
            elif name.startswith('$') or name.startswith('__'):
                # skip internal names
                continue

            # sort into text, data, and other symbols
            if st_shndx == seg_text:
                text_symbols[st_value] = name
            elif st_shndx == seg_data and seg_data >= 0:
                data_symbols[st_value] = name
            else:
                other_symbols[st_value] = name


        # round to page boundaries at both ends
        memory_start &= ~4095
        memory_end = (memory_end + 4095) & ~4095

        assert(text_start != 0 and text_end != 0)
        assert(text_start <= e_entry < text_end)

        # allocate a page of stack
        #print(f'allocated {(memory_end - memory_start) // 1024}k address space from 0x{memory_start:x} to 0x{memory_end:x} (not including 4k stack)')

        # allocate address space
        m = Machine(memory_start, memory_end, e_entry, text_start, text_end, text_symbols, data_symbols, other_symbols, global_pointer)

        # second pass--load the segments
        for i in range(e_phnum):
            # unpack the program header
            #print(f'unpacking program header {i+1}')
            start = e_phoff + e_phentsize*i
            (
                p_type, p_flags, p_offset, p_vaddr, p_paddr, p_filesz, p_memsz, p_align
            ) = struct.unpack('<2I6Q', raw[start:start+e_phentsize])

            if p_type != 1:
                #print('    skipping non-loadable segment')
                continue
            #print(f'    loading segment from offset 0x{p_offset:x} with size 0x{p_filesz:x}')
            #print(f'    into virtual address 0x{p_vaddr:x} with size 0x{p_memsz:x}')

            for i in range(p_filesz):
                m.sb(p_vaddr + i, raw[p_offset + i])

        # m has been recording memory write effects, so reset it
        m.gather_effects()
        return m

# instruction decoders
def get_funct3(inst: int) -> int:
    return (inst>>12) & 0x07

def get_rd(inst: int) -> int:
    return (inst>>7) & 0x1f

def get_rs1(inst: int) -> int:
    return (inst>>15) & 0x1f

def get_rs2(inst: int) -> int:
    return (inst>>20) & 0x1f

def get_imm_i(inst: int) -> int:
    return inst >> 20

def get_imm_s(inst: int) -> int:
    imm =  (inst >> 20) & ~0x0000001f
    imm |= (inst >> 7)  &  0x0000001f
    return imm

def get_imm_b(inst: int) -> int:
    imm =  (inst >> 20) & ~0x00000fff
    imm |= (inst << 4)  &  0x00000800
    imm |= (inst >> 20) &  0x000007e0
    imm |= (inst >> 7)  &  0x0000001e
    return imm

def get_imm_u(inst: int) -> int:
    return inst & ~0x00000fff

def get_imm_j(inst: int) -> int:
    imm =  (inst >> 11) & ~0x000fffff
    imm |=  inst        &  0x000ff000
    imm |= (inst >> 9)  &  0x00000800
    imm |= (inst >> 20) &  0x000007e0
    imm |= (inst >> 20) &  0x0000001e
    return imm

def get_funct7(inst: int) -> int:
    return inst >> 25

r = [
    'zero', 'ra', 'sp', 'gp', 'tp', 't0', 't1', 't2',
    's0', 's1', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5',
    'a6', 'a7', 's2', 's3', 's4', 's5', 's6', 's7',
    's8', 's9', 's10', 's11', 't3', 't4', 't5', 't6',
    'zero', 'ra', 'sp', 'gp', 'tp', 't0', 't1', 't2',
    's0', 's1', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5',
    'a6', 'a7', 's2', 's3', 's4', 's5', 's6', 's7',
    's8', 's9', 's10', 's11', 't3', 't4', 't5', 't6',
]

def decode(labels: Machine, address: int, inst: int) -> Instruction:
    # divide the instructions up according the main instruction opcode
    # then call a specialized function for each opcode to do the rest
    opcode = inst & 0x7f
    match opcode:
        # lui
        case 0x37:
            return decode_lui(address, inst, get_rd(inst), get_imm_u(inst))

        # auipc
        case 0x17:
            return decode_auipc(address, inst, get_rd(inst), get_imm_u(inst))

        # jal
        case 0x6f:
            return decode_jal(labels, address, inst, get_rd(inst), get_imm_j(inst))

        # jalr
        case 0x67:
            return decode_jalr(address, inst, get_funct3(inst), get_rd(inst), get_rs1(inst), get_imm_i(inst))

        # beq, bne, blt, bge, bltu, bgeu
        case 0x63:
            return decode_branches(labels, address, inst, get_funct3(inst), get_rs1(inst), get_rs2(inst), get_imm_b(inst))

        # lb, lh, lw, ld, lbu, lhu, lwu
        case 0x03:
            return decode_load(address, inst, get_funct3(inst), get_rd(inst), get_rs1(inst), get_imm_i(inst))

        # sb, sh, sw, sd
        case 0x23:
            return decode_store(address, inst, get_funct3(inst), get_rs1(inst), get_rs2(inst), get_imm_s(inst))

        # addi, slti, sltiu, xori, ori, andi, slli, srli, srai
        case 0x13:
            return decode_alu_imm(labels, address, inst, get_funct3(inst), get_rd(inst), get_rs1(inst), get_imm_i(inst))

        # addiw, slliw, srliw, sraiw
        case 0x1b:
            return decode_alu_imm_w(labels, address, inst, get_funct3(inst), get_rd(inst), get_rs1(inst), get_imm_i(inst))

        # add, sub, sll, slt, sltu, xor, srl, sra, or, and
        # mul, mulh, mulhsu, mulhu, div, divu, rem, remu
        case 0x33:
            return decode_alu(address, inst, get_funct3(inst), get_rd(inst), get_rs1(inst), get_rs2(inst), get_funct7(inst))

        # addw, subw, sllw, srlw, sraw
        # mulw, divw, remw, remuw
        case 0x3b:
            return decode_alu_w(address, inst, get_funct3(inst), get_rd(inst), get_rs1(inst), get_rs2(inst), get_funct7(inst))

        # fence
        case 0x0f:
            def execute_fence(m: Machine) -> None:
                # do nothing
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['fence', '*'], execute_fence)

        # ecall, ebreak
        case 0x73:
            if inst == 0x00000073:
                return decode_ecall(address, inst)

                # TODO: if ecall was an exit syscall we quit gracefully
            elif inst == 0x00100073:
                # handle ebreak here--exit
                def execute_ebreak(m: Machine) -> None:
                    m.other_message = 'ebreak'
                    m.terminate = True

                return Instruction(address, inst, ['ebreak'], execute_ebreak,
                    fallthrough=False)

    raise Fault(f'unknown opcode {opcode}')

def decode_lui(address: int, inst: int, rd: int, imm: int) -> Instruction:
    def execute_lui(m: Machine) -> None:
        m.set(rd, imm)
        m.set_pc(m.pc + 4)

    return Instruction(address, inst, ['lui', r[rd], str(imm)], execute_lui)

def decode_auipc(address: int, inst: int, rd: int, imm: int) -> Instruction:
    def execute_auipc(m: Machine) -> None:
        m.set(rd, m.pc + imm)
        m.set_pc(m.pc + 4)

    return Instruction(address, inst, ['auipc', r[rd], str(imm)], execute_auipc)

def decode_jal(labels: Machine, address: int, inst: int, rd: int, imm: int) -> Instruction:
    def execute_jal(m: Machine) -> None:
        m.set(rd, m.pc + 4)
        m.set_pc(m.pc + imm)

    dest = labels.text_label(address+imm)
    if r[rd] == 'zero':
        fields = ['j', dest]
    elif r[rd] == 'ra':
        fields = ['call', dest]
    else:
        fields = ['jal', r[rd], dest]
    return Instruction(address, inst, fields, execute_jal,
        static_target=address + imm, fallthrough=False, return_target=None if rd == 0 else address + 4)

def decode_jalr(address: int, inst: int, funct3: int, rd: int, rs1: int, imm: int) -> Instruction:
    if funct3 != 0:
        raise Fault(f'jalr with unknown funct3 value of {funct3}')

    def execute_jalr(m: Machine) -> None:
        # rd and rs1 could be the same, so capture rs1 before setting rd
        rs1_val = m.get(rs1)
        m.set(rd, m.pc + 4)
        m.set_pc((rs1_val + imm) & ~1)

    match (r[rd], imm, r[rs1]):
        case ('zero', 0, 'ra'):
            fields = ['ret']
        case ('zero', 0, _):
            fields = ['jr', r[rs1]]
        case ('ra', 0, _):
            fields = ['jalr', r[rs1]]
        case (_, 0, _):
            fields = ['jalr', r[rd], f'({r[rs1]})']
        case _:
            fields = ['jalr', r[rd], f'{imm}({r[rs1]})']

    return Instruction(address, inst, fields, execute_jalr,
        fallthrough=False, return_target=None if rd == 0 else address + 4)

def decode_branches(labels: Machine, address: int, inst: int, funct3: int, rs1: int, rs2: int, imm: int) -> Instruction:
    match funct3:
        case 0:
            def execute_beq(m: Machine) -> None:
                if m.get(rs1) == m.get(rs2):
                    m.set_pc(m.pc + imm)
                else:
                    m.set_pc(m.pc + 4)

            dest = labels.text_label(address+imm, pc=address)
            if r[rs1] == 'zero':
                fields = ['beqz', r[rs2], dest]
            elif r[rs2] == 'zero':
                fields = ['beqz', r[rs1], dest]
            else:
                fields = ['beq', r[rs1], r[rs2], dest]

            return Instruction(address, inst, fields, execute_beq,
                static_target=address+imm)

        case 1:
            def execute_bne(m: Machine) -> None:
                if m.get(rs1) != m.get(rs2):
                    m.set_pc(m.pc + imm)
                else:
                    m.set_pc(m.pc + 4)

            dest = labels.text_label(address+imm, pc=address)
            if r[rs1] == 'zero':
                fields = ['bnez', r[rs2], dest]
            elif r[rs2] == 'zero':
                fields = ['bnez', r[rs1], dest]
            else:
                fields = ['bne', r[rs1], r[rs2], dest]
            return Instruction(address, inst, fields, execute_bne,
                static_target=address+imm)

        case 4:
            def execute_blt(m: Machine) -> None:
                if m.get(rs1) < m.get(rs2):
                    m.set_pc(m.pc + imm)
                else:
                    m.set_pc(m.pc + 4)

            dest = labels.text_label(address+imm, pc=address)
            if r[rs1] == 'zero':
                fields=['bgtz', r[rs2], dest]
            elif r[rs2] == 'zero':
                fields=['bltz', r[rs1], dest]
            else:
                fields=['blt', r[rs1], r[rs2], dest]

            return Instruction(address, inst, fields, execute_blt,
                static_target=address+imm)

        case 5:
            def execute_bge(m: Machine) -> None:
                if m.get(rs1) >= m.get(rs2):
                    m.set_pc(m.pc + imm)
                else:
                    m.set_pc(m.pc + 4)

            dest = labels.text_label(address+imm, pc=address)
            if r[rs1] == 'zero':
                fields=['blez', r[rs2], dest]
            elif r[rs2] == 'zero':
                fields=['bgez', r[rs1], dest]
            else:
                fields=['bge', r[rs1], r[rs2], dest]

            return Instruction(address, inst, fields, execute_bge,
                static_target=address+imm)

        case 6:
            def execute_bltu(m: Machine) -> None:
                if unsigned(m.get(rs1)) < unsigned(m.get(rs2)):
                    m.set_pc(m.pc + imm)
                else:
                    m.set_pc(m.pc + 4)

            dest = labels.text_label(address+imm, pc=address)

            return Instruction(address, inst, ['bltu', r[rs1], r[rs2], dest], execute_bltu,
                static_target=address+imm)

        case 7:
            def execute_bgeu(m: Machine) -> None:
                if unsigned(m.get(rs1)) >= unsigned(m.get(rs2)):
                    m.set_pc(m.pc + imm)
                else:
                    m.set_pc(m.pc + 4)

            dest = labels.text_label(address+imm, pc=address)

            return Instruction(address, inst, ['bgeu', r[rs1], r[rs2], dest], execute_bgeu,
                static_target=address+imm)

        case _:
            raise Fault(f'branch of unknown type {funct3}')

def decode_load(address: int, inst: int, funct3: int, rd: int, rs1: int, imm: int) -> Instruction:
    match funct3:
        case 0:
            def execute_lb(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.lb(effective_address))
                m.set_pc(m.pc + 4)

            fields=['lb', r[rd], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_lb)

        case 1:
            def execute_lh(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.lh(effective_address))
                m.set_pc(m.pc + 4)

            fields=['lh', r[rd], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_lh)

        case 2:
            def execute_lw(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.lw(effective_address))
                m.set_pc(m.pc + 4)

            fields=['lw', r[rd], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_lw)

        case 3:
            def execute_ld(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.ld(effective_address))
                m.set_pc(m.pc + 4)

            fields=['ld', r[rd], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_ld)

        case 4:
            def execute_lbu(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.lbu(effective_address))
                m.set_pc(m.pc + 4)

            fields=['lbu', r[rd], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_lbu)

        case 5:
            def execute_lhu(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.lhu(effective_address))
                m.set_pc(m.pc + 4)

            fields=['lhu', r[rd], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_lhu)

        case 6:
            def execute_lwu(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.lwu(effective_address))
                m.set_pc(m.pc + 4)

            fields=['lwu', r[rd], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_lwu)

    raise Fault(f'load instruction of unknown type {funct3}')

def decode_store(address: int, inst: int, funct3: int, rs1: int, rs2: int, imm: int) -> Instruction:
    match funct3:
        case 0:
            def execute_sb(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                val8 = m.get(rs2) & 0xff
                m.sb(effective_address, val8)
                m.set_pc(m.pc + 4)

            fields=['sb', r[rs2], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_sb)

        case 1:
            def execute_sh(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                val16 = m.get(rs2) & 0xffff
                m.sh(effective_address, val16)
                m.set_pc(m.pc + 4)

            fields=['sh', r[rs2], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_sh)

        case 2:
            def execute_sw(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                val32 = m.get(rs2) & 0xffffffff
                m.sw(effective_address, val32)
                m.set_pc(m.pc + 4)

            fields=['sw', r[rs2], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_sw)

        case 3:
            def execute_sd(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.sd(effective_address, m.get(rs2))
                m.set_pc(m.pc + 4)

            fields=['sd', r[rs2], ('' if imm == 0 else str(imm)) + f'({r[rs1]})']

            return Instruction(address, inst, fields, execute_sd)

    raise Fault(f'store instruction of unknown type {funct3}')

def decode_alu_imm(labels: Machine, address: int, inst: int, funct3: int, rd: int, rs1: int, imm: int) -> Instruction:
    shamt = imm & 0x3f
    imm_high = imm>>6

    match funct3:
        case 0:
            def execute_addi(m: Machine) -> None:
                m.set(rd, m.get(rs1) + imm)
                m.set_pc(m.pc + 4)

            match (r[rd], r[rs1], imm):
                case ('zero', 'zero', 0):
                    fields=['nop']
                case (_, 'zero', _):
                    fields=['li', r[rd], labels.misc_label(imm)]
                case (_, _, 0):
                    fields=['mv', r[rd], r[rs1]]
                case (_, 'gp', _) if r[rd] != 'gp':
                    fields=['la', r[rd], labels.data_label(labels.global_pointer + imm)]
                case _:
                    fields=['addi', r[rd], r[rs1], str(imm)]

            return Instruction(address, inst, fields, execute_addi)

        case 2:
            def execute_slti(m: Machine) -> None:
                m.set(rd, 1 if m.get(rs1) < imm else 0)
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['slti', r[rd], r[rs1], str(imm)], execute_slti)

        case 3:
            def execute_sltiu(m: Machine) -> None:
                m.set(rd, 1 if unsigned(m.get(rs1)) < unsigned(imm) else 0)
                m.set_pc(m.pc + 4)

            if imm == 1:
                fields=['seqz', r[rd], r[rs1]]
            else:
                fields=['sltiu', r[rd], r[rs1], str(imm)]

            return Instruction(address, inst, fields, execute_sltiu)

        case 4:
            def execute_xori(m: Machine) -> None:
                m.set(rd, m.get(rs1) ^ unsigned(imm))
                m.set_pc(m.pc + 4)

            if imm == -1:
                fields=['not', r[rd], r[rs1]]
            else:
                fields=['xori', r[rd], r[rs1], str(imm)]

            return Instruction(address, inst, fields, execute_xori)

        case 6:
            def execute_ori(m: Machine) -> None:
                m.set(rd, m.get(rs1) | imm)
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['ori', r[rd], r[rs1], str(imm)], execute_ori)

        case 7:
            def execute_andi(m: Machine) -> None:
                m.set(rd, m.get(rs1) & imm)
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['andi', r[rd], r[rs1], str(imm)], execute_andi)

        case 1:
            if imm_high != 0x00:
                raise Fault(f'immediate mode alu instruction of type {funct3} with unknown subtype {imm_high}')

            def execute_slli(m: Machine) -> None:
                m.set(rd, m.get(rs1) << shamt)
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['slli', r[rd], r[rs1], str(shamt)], execute_slli)

        case 5:
            if imm_high == 0x00:
                def execute_srli(m: Machine) -> None:
                    m.set(rd, unsigned(m.get(rs1)) >> shamt)
                    m.set_pc(m.pc + 4)

                return Instruction(address, inst, ['srli', r[rd], r[rs1], str(shamt)], execute_srli)

            elif imm_high == 0x10:
                def execute_srai(m: Machine) -> None:
                    m.set(rd, m.get(rs1) >> shamt)
                    m.set_pc(m.pc + 4)

                return Instruction(address, inst, ['srai', r[rd], r[rs1], str(shamt)], execute_srai)

            raise Fault(f'immediate mode alu instruction of type {funct3} with unknown subtype {imm_high}')

    raise Fault(f'immediate mode alu instruction of unknown type {funct3}')

def decode_alu_imm_w(labels: Machine, address: int, inst: int, funct3: int, rd: int, rs1: int, imm: int) -> Instruction:
    shamt = imm & 0x1f
    imm_high = imm>>5

    match funct3:
        case 0:
            def execute_addiw(m: Machine) -> None:
                m.set32(rd, m.get(rs1) + imm)
                m.set_pc(m.pc + 4)

            match (r[rd], r[rs1], imm):
                case ('zero', 'zero', 0):
                    fields=['nop']
                case (_, 'zero', _):
                    fields=['li', r[rd], labels.misc_label(imm)]
                case _:
                    fields=['addiw', r[rd], r[rs1], str(imm)]

            return Instruction(address, inst, fields, execute_addiw)

        case 1:
            if imm_high != 0x00:
                raise Fault(f'immediate mode alu w instruction of type {funct3} with unknown subtype {imm_high}')

            def execute_slliw(m: Machine) -> None:
                m.set32(rd, m.get(rs1) << shamt)
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['slliw', r[rd], r[rs1], str(shamt)], execute_slliw)

        case 5:
            if imm_high == 0x00:
                def execute_srliw(m: Machine) -> None:
                    m.set32(rd, unsigned32(m.get(rs1)) >> shamt)
                    m.set_pc(m.pc + 4)

                return Instruction(address, inst, ['srliw', r[rd], r[rs1], str(shamt)], execute_srliw)

            elif imm_high == 0x20:
                def execute_sraiw(m: Machine) -> None:
                    m.set32(rd, clip32(m.get(rs1)) >> shamt)
                    m.set_pc(m.pc + 4)

                return Instruction(address, inst, ['sraiw', r[rd], r[rs1], str(shamt)], execute_sraiw)

            raise Fault(f'immediate mode alu w instruction of type {funct3} with unknown subtype {imm_high}')

    raise Fault(f'immediate mode alu w instruction of unknown type {funct3}')

def decode_alu(address: int, inst: int, funct3: int, rd: int, rs1: int, rs2: int, funct7: int) -> Instruction:
    combined = (funct7 << 8) | funct3

    match combined:
        case 0x0000:
            def execute_add(m: Machine) -> None:
                m.set(rd, m.get(rs1) + m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['add', r[rd], r[rs1], r[rs2]], execute_add)

        case 0x2000:
            def execute_sub(m: Machine) -> None:
                m.set(rd, m.get(rs1) - m.get(rs2))
                m.set_pc(m.pc + 4)

            if r[rs1] == 'zero':
                fields=['neg', r[rd], r[rs2]]
            else:
                fields=['sub', r[rd], r[rs1], r[rs2]]

            return Instruction(address, inst, fields, execute_sub)

        case 0x0001:
            def execute_sll(m: Machine) -> None:
                m.set(rd, m.get(rs1) << (m.get(rs2) & 0x3f))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['sll', r[rd], r[rs1], r[rs2]], execute_sll)

        case 0x0002:
            def execute_slt(m: Machine) -> None:
                m.set(rd, 1 if m.get(rs1) < m.get(rs2) else 0)
                m.set_pc(m.pc + 4)

            if r[rs2] == 'zero':
                fields=['sltz', r[rd], r[rs1]]
            elif r[rs1] == 'zero':
                fields=['sgtz', r[rd], r[rs2]]
            else:
                fields=['slt', r[rd], r[rs1], r[rs2]]

            return Instruction(address, inst, fields, execute_slt)

        case 0x0003:
            def execute_sltu(m: Machine) -> None:
                m.set(rd, 1 if unsigned(m.get(rs1)) < unsigned(m.get(rs2)) else 0)
                m.set_pc(m.pc + 4)

            if r[rs1] == 'zero':
                fields=['snez', r[rd], r[rs2]]
            else:
                fields=['sltu', r[rd], r[rs1], r[rs2]]

            return Instruction(address, inst, fields, execute_sltu)

        case 0x0004:
            def execute_xor(m: Machine) -> None:
                m.set(rd, m.get(rs1) ^ m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['xor', r[rd], r[rs1], r[rs2]], execute_xor)

        case 0x0005:
            def execute_srl(m: Machine) -> None:
                m.set(rd, unsigned(m.get(rs1)) >> (m.get(rs2) & 0x3f))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['srl', r[rd], r[rs1], r[rs2]], execute_srl)

        case 0x2005:
            def execute_sra(m: Machine) -> None:
                m.set(rd, m.get(rs1) >> (m.get(rs2) & 0x3f))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['sra', r[rd], r[rs1], r[rs2]], execute_sra)

        case 0x0006:
            def execute_or(m: Machine) -> None:
                m.set(rd, m.get(rs1) | m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['or', r[rd], r[rs1], r[rs2]], execute_or)

        case 0x0007:
            def execute_and(m: Machine) -> None:
                m.set(rd, m.get(rs1) & m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['and', r[rd], r[rs1], r[rs2]], execute_and)

        case 0x0100:
            def execute_mul(m: Machine) -> None:
                m.set(rd, m.get(rs1) * m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['mul', r[rd], r[rs1], r[rs2]], execute_mul)

        case 0x0101:
            def execute_mulh(m: Machine) -> None:
                m.set(rd, (m.get(rs1) * m.get(rs2)) >> 64)
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['mulh', r[rd], r[rs1], r[rs2]], execute_mulh)

        case 0x0102:
            def execute_mulhsu(m: Machine) -> None:
                m.set(rd, (m.get(rs1) * unsigned(m.get(rs2))) >> 64)
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['mulhsu', r[rd], r[rs1], r[rs2]], execute_mulhsu)

        case 0x0103:
            def execute_mulhu(m: Machine) -> None:
                m.set(rd, (unsigned(m.get(rs1)) * unsigned(m.get(rs2))) >> 64)
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['mulhu', r[rd], r[rs1], r[rs2]], execute_mulhu)

        case 0x0104:
            def execute_div(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set(rd, -1)
                else:
                    m.set(rd, int(m.get(rs1) / m.get(rs2)))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['div', r[rd], r[rs1], r[rs2]], execute_div)

        case 0x0105:
            def execute_divu(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set(rd, -1)
                else:
                    m.set(rd, unsigned(m.get(rs1)) // unsigned(m.get(rs2)))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['divu', r[rd], r[rs1], r[rs2]], execute_divu)

        case 0x0106:
            def execute_rem(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set(rd, m.get(rs1))
                else:
                    m.set(rd, m.get(rs1) - int(m.get(rs1) / m.get(rs2)) * m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['rem', r[rd], r[rs1], r[rs2]], execute_rem)

        case 0x0107:
            def execute_remu(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set(rd, m.get(rs1))
                else:
                    m.set(rd, unsigned(m.get(rs1)) % unsigned(m.get(rs2)))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['remu', r[rd], r[rs1], r[rs2]], execute_remu)

    raise Fault(f'alu instruction of unknown type {funct3} subtype {funct7}')

def decode_alu_w(address: int, inst: int, funct3: int, rd: int, rs1: int, rs2: int, funct7: int) -> Instruction:
    combined = (funct7 << 8) | funct3

    match combined:
        case 0x0000:
            def execute_addw(m: Machine) -> None:
                m.set32(rd, m.get(rs1) + m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['addw', r[rd], r[rs1], r[rs2]], execute_addw)

        case 0x2000:
            def execute_subw(m: Machine) -> None:
                m.set32(rd, m.get(rs1) - m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['subw', r[rd], r[rs1], r[rs2]], execute_subw)

        case 0x0001:
            def execute_sllw(m: Machine) -> None:
                m.set32(rd, m.get(rs1) << (m.get(rs2) & 0x1f))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['sllw', r[rd], r[rs1], r[rs2]], execute_sllw)

        case 0x0005:
            def execute_srlw(m: Machine) -> None:
                m.set32(rd, unsigned32(m.get(rs1)) >> (m.get(rs2) & 0x1f))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['srlw', r[rd], r[rs1], r[rs2]], execute_srlw)

        case 0x2005:
            def execute_sraw(m: Machine) -> None:
                m.set32(rd, clip32(m.get(rs1)) >> (m.get(rs2) & 0x1f))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['sraw', r[rd], r[rs1], r[rs2]], execute_sraw)

        case 0x0100:
            def execute_mulw(m: Machine) -> None:
                m.set32(rd, m.get(rs1) * m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['mulw', r[rd], r[rs1], r[rs2]], execute_mulw)

        case 0x0104:
            def execute_divw(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set32(rd, -1)
                else:
                    m.set32(rd, int(m.get(rs1) / m.get(rs2)))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['divw', r[rd], r[rs1], r[rs2]], execute_divw)

        case 0x0105:
            def execute_divuw(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set32(rd, -1)
                else:
                    m.set32(rd, unsigned(m.get(rs1)) // unsigned(m.get(rs2)))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['divuw', r[rd], r[rs1], r[rs2]], execute_divuw)

        case 0x0106:
            def execute_remw(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set32(rd, m.get(rs1))
                else:
                    m.set32(rd, m.get(rs1) - int(m.get(rs1) / m.get(rs2)) * m.get(rs2))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['remw', r[rd], r[rs1], r[rs2]], execute_remw)

        case 0x0107:
            def execute_remuw(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set32(rd, m.get(rs1))
                else:
                    m.set32(rd, unsigned(m.get(rs1)) % unsigned(m.get(rs2)))
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, ['remuw', r[rd], r[rs1], r[rs2]], execute_remuw)

    raise Fault(f'alu w instruction of unknown type {funct3} subtype {funct7}')


def decode_ecall(address: int, inst: int) -> Instruction:
    def execute_ecall(m: Machine) -> None:
        if m.get(17) == 63:
            # read system call
            m.other_message = f'read({m.get(10)}, {hex(m.get(11))}, {m.get(12)})'
            if m.get(10) != 0:
                raise Fault(f'Invalid file descriptor in read system call: {m.get(10)} but only 0 (stdin) is supported')
            if m.get(12) < 0:
                raise Fault(f'Invalid buffer size in read system call: {m.get(12)}')

            if      m.get(11) >= m.memory_start and m.get(11) + m.get(12) <= m.memory_end or \
                    m.get(11) >= m.stack_start  and m.get(11) + m.get(12) <= m.stack_end:
                read_res = sys.stdin.buffer.read(m.get(12))
                for (i, b) in enumerate(read_res):
                    m.sb(m.get(11) + i, b)
                m.set(10, len(read_res))
                m.stdin_delta = read_res
                m.stdin += read_res
                m.set_pc(m.pc + 4)
                return
            else:
                raise Fault(f'Invalid memory range in read system call: {m.get(11)} to {m.get(11)+m.get(12)}')

        if m.get(17) == 64:
            # write system call
            m.other_message = f'write({m.get(10)}, {hex(m.get(11))}, {m.get(12)})'
            if m.get(10) != 1:
                raise Fault(f'Invalid file descriptor in write system call: {m.get(10)} but only 1 (stdout) is supported')
            if m.get(12) < 0:
                raise Fault(f'Invalid buffer size in write system call: {m.get(12)}')

            if      m.get(11) >= m.memory_start and m.get(11) + m.get(12) <= m.memory_end or \
                    m.get(11) >= m.stack_start  and m.get(11) + m.get(12) <= m.stack_end:
                buf = bytearray(m.get(12))
                for i, addr in enumerate(range(m.get(11), m.get(11) + m.get(12))):
                    buf[i] = m.lbu(addr)
                m.set(10, len(buf))
                m.stdout_delta = bytes(buf)
                m.stdout += buf
                m.set_pc(m.pc + 4)
                return
            else:
                raise Fault(f'Invalid memory range in write system call: {m.get(11)} to {m.get(11)+m.get(12)}')

        if m.get(17) == 93:
            # exit system call
            m.other_message = f'exit({m.get(10)})'
            m.terminate = True
            return

        # unimplemented
        raise Fault(f'unsupported syscall {m.get(17)}')

    return Instruction(address, inst, ['ecall'], execute_ecall)

def pair_instructions(m: Machine, instructions: dict[int, Instruction]) -> None:
    for pc in range(m.text_start, m.text_end, 4):
        instruction = instructions[pc]
        if pc+4 < m.text_end:
            instruction2 = instructions[pc+4]
            match (instruction, instruction2):
                case (Instruction(fields=['auipc', rd0, imm0]),
                      Instruction(fields=['addi', rd, rs1, imm])) if rd0 == rd and rs1 == rd:
                    addr = pc + int(imm0) + int(imm)
                    if m.text_start <= addr <= m.text_end:
                        sym = m.text_label(addr, pc=pc)
                    else:
                        sym = m.data_label(addr)
                    instruction.fields = ['auipc', rd0, imm0, f'[la {rd0}, {sym}]']

def add_labels(m: Machine, instructions: dict[int, Instruction]) -> None:
    # add labels from the symbol table and note branch targets
    for (pc, instruction) in instructions.items():
        if pc in m.text_symbols:
            instruction.label = m.text_symbols[pc]
        if instruction.static_target is not None:
            instructions[instruction.static_target].is_target = True

    # add numbered local labels
    next_label = 1
    fn_name = ''
    next_fn = {}
    prev = -1
    for pc in range(m.text_start, m.text_end, 4):
        instruction = instructions[pc]
        if instruction.label is None and instruction.is_target:
            instruction.label = str(next_label)
            next_label += 1
        elif instruction.label is not None:
            fn_name = instruction.label
            next_label = 1
            if prev >= 0:
                next_fn[prev] = pc
            prev = pc
    if prev >= 0:
        next_fn[prev] = m.text_end

    # update branches to reference local labels
    fn_start = 0
    for pc in range(m.text_start, m.text_end, 4):
        instruction = instructions[pc]
        if instruction.label is not None and not instruction.label.isdigit():
            fn_start = pc
            fn_end = next_fn[fn_start]
        match instruction.fields:
            case ['j', dest]:
                pass
            case ['beqz', _, dest]:
                pass
            case ['beq', _, _, dest]:
                pass
            case ['bnez', _, dest]:
                pass
            case ['bne', _, _, dest]:
                pass
            case ['bgtz', _, dest]:
                pass
            case ['bltz', _, dest]:
                pass
            case ['blt', _, _, dest]:
                pass
            case ['blez', _, dest]:
                pass
            case ['bgez', _, dest]:
                pass
            case ['bge', _, _, dest]:
                pass
            case ['bltu', _, _, dest]:
                pass
            case ['bgeu', _, _, dest]:
                pass
            case _:
                continue
        if not dest.isdigit():
            continue

        # ignore branches outside the current function
        addr = int(dest)
        if addr < fn_start or addr >= fn_end:
            continue

        target_label = instructions[addr].label
        assert(target_label is not None)
        if target_label.isdigit():
            if addr < pc:
                instruction.fields[-1] = f'{target_label}b'
            elif addr > pc:
                instruction.fields[-1] = f'{target_label}f'

def pre_trace(m: Machine, instructions: dict[int, Instruction], echo: bool=False) -> list[tuple[Instruction, Effects]]:
    sequence = []
    while True:
        # fetch the next instruction
        instruction = instructions[m.pc]
        try:
            instruction.execute(m)
        except Fault as err:
            m.other_message = err.msg
            m.terminate = True
        e = m.gather_effects()
        sequence.append( (instruction, e) )
        if echo and e.stdout is not None:
            sys.stdout.buffer.write(e.stdout)
            sys.stdout.flush()
        if e.terminate:
            break

    # now rewind
    for (instruction, e) in reversed(sequence):
        apply(m, e, False)

    return sequence

def find_function_bounds(m: Machine, pc: int) -> tuple[int, int]:
    assert(pc >= m.text_start and pc < m.text_end and pc%4 == 0)
    for start in range(pc, m.text_start-4, -4):
        if start in m.text_symbols:
            break
    for end in range(pc+4, m.text_end, 4):
        if end in m.text_symbols:
            break
    return (start, end)

def render_line(instruction: Instruction, effects: Optional[Effects]) -> list[str]:
    disasm = f'{instruction.fields[0]:<8}' + ', '.join(instruction.fields[1:])
    if instruction.label is None:
        addr_part = ''
    else:
        addr_part = instruction.label + ':'
    result = [f'{addr_part:<20}{disasm:<48}']
    if effects is None:
        return result

    result[0] += report_effects(effects)

    if effects.other_message is not None:
        result.append(f'{"":20}{effects.other_message}')
    if effects.stdin is not None:
        result.append(f'{"":20}{repr(effects.stdin.decode())}')
    if effects.stdout is not None:
        result.append(f'{"":20}{repr(effects.stdout.decode())}')

    return result

def ui(m: Machine, instructions: dict[int, Instruction], sequence: list[tuple[Instruction, Effects]]) -> None:
    # take over terminal
    stdscr = curses.initscr()
    curses.noecho()
    curses.cbreak()
    stdscr.keypad(True)
    stdscr.clear()
    curses.curs_set(0)
    curses.start_color()

    # colors:
    # 0 = normal line (white on black, built-in)
    # 1 = current pc
    curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_GREEN)
    # 2 = cursor (if != pc)
    curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_WHITE)

    # handle screen resizes
    source_view: Optional[curses.window] = None
    (source_height, source_width) = (0, 0)
    active = True
    def resize() -> None:
        nonlocal source_view, source_height, source_width, active
        (height, width) = stdscr.getmaxyx()
        source_height = height
        source_width = width
        if source_height < 3 or source_width < 5:
            active = False
            return
        active = True
        if source_view is None:
            source_view = curses.newwin(source_height, source_width, 0, 0)
        else:
            source_view.resize(source_height, source_width)
    resize()

    seq_i = 0
    cursor_addr = sequence[seq_i][0].address
    pc = cursor_addr

    def draw_source() -> None:
        nonlocal source_view, source_height, source_width, active, seq_i, cursor_addr, pc
        if not active: return
        source_view.erase()
        source_view.box()
        middle = (source_height-2) // 2
        for i in range(source_height-2):
            addr = cursor_addr - middle*4 + i*4
            if addr == pc:
                (instruction, effects) = sequence[seq_i]
                lines = render_line(instruction, effects)
                color = curses.color_pair(1)
            elif addr in instructions:
                instruction = instructions[addr]
                lines = render_line(instruction, None)
                if addr == cursor_addr:
                    color = curses.color_pair(2)
                else:
                    color = curses.color_pair(0)
            else:
                lines = ['']
                color = curses.color_pair(0)
            source_view.addstr(i+1, 1, lines[0][:source_width-2].ljust(source_width-2), color)
        status_line = f' {seq_i+1}/{len(sequence)} PC: {hex(pc)} '[:source_width-4]
        source_view.addstr(source_height-1, 3, status_line)
        source_view.noutrefresh()
        curses.doupdate()

    draw_source()
    stdscr.noutrefresh()

    while True:
        key = stdscr.getch()
        if key == curses.KEY_RIGHT and seq_i+1 < len(sequence):
            apply(m, sequence[seq_i][1], True)
            seq_i += 1
            pc = sequence[seq_i][0].address
            cursor_addr = pc
            draw_source()
        elif key == curses.KEY_LEFT and seq_i > 0:
            apply(m, sequence[seq_i][1], False)
            seq_i -= 1
            pc = sequence[seq_i][0].address
            cursor_addr = pc
            draw_source()
        elif key == curses.KEY_UP and cursor_addr-4 >= m.text_start:
            cursor_addr -= 4
            draw_source()
        elif key == curses.KEY_DOWN and cursor_addr+4 < m.text_end:
            cursor_addr += 4
            draw_source()
        elif key == curses.KEY_PPAGE and cursor_addr-4 >= m.text_start:
            cursor_addr -= 4*(source_height - 2)
            if cursor_addr < m.text_start:
                cursor_addr = m.text_start
            draw_source()
        elif key == curses.KEY_NPAGE and cursor_addr+4 >= m.text_start:
            cursor_addr += 4*(source_height - 2)
            if cursor_addr >= m.text_end:
                cursor_addr = m.text_end-4
            draw_source()
        elif key in (curses.KEY_ENTER, ord('\n')):
            # find the next time the pc reaches this address
            for peek in range(seq_i+1, len(sequence)):
                if sequence[peek][0].address == cursor_addr:
                    # play the sequence forward to this point
                    for seq_i in range(seq_i, peek+1):
                        apply(m, sequence[seq_i][1], True)
                    pc = sequence[seq_i][0].address
                    cursor_addr = pc
                    draw_source()
                    break
        elif key in (curses.KEY_BACKSPACE , ord('\b'), ord('\x7f')):
            # find the previous time the pc was at this address
            for peek in range(seq_i-1, -1, -1):
                if sequence[peek][0].address == cursor_addr:
                    # play the sequence backward to this point
                    for seq_i in range(seq_i-1, peek-1, -1):
                        apply(m, sequence[seq_i][1], False)
                    pc = sequence[seq_i][0].address
                    cursor_addr = pc
                    draw_source()
                    break
        elif key == curses.KEY_HOME:
            # jump back to when current function was called
            (func_start, func_end) = find_function_bounds(m, pc)

            first = True
            for seq_i in range(seq_i, -1, -1):
                pc = sequence[seq_i][0].address
                cursor_addr = pc
                if first:
                    first = False
                else:
                    apply(m, sequence[seq_i][1], False)
                if func_start <= pc < func_end and (seq_i == 0 or sequence[seq_i-1][0].fields[0] == 'call'):
                    break
            draw_source()
        elif key == curses.KEY_END:
            # find the next return (or end of program) from current function
            (func_start, func_end) = find_function_bounds(m, pc)
            for seq_i in range(seq_i, len(sequence)):
                pc = sequence[seq_i][0].address
                cursor_addr = pc
                if func_start <= pc < func_end and sequence[seq_i][0].fields[0] == 'ret':
                    break
                apply(m, sequence[seq_i][1], True)
            draw_source()

        elif key == curses.KEY_RESIZE:
            resize()
            draw_source()
            draw_source()

        elif key == ord('q'):
            break

    # restore terminal
    curses.nocbreak()
    stdscr.keypad(False)
    curses.echo()
    curses.endwin()

def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument('-m', '--mode',
        choices=['run', 'trace', 'dasm', 'step'],
        default='trace')
    parser.add_argument('-e', '--executable',
        default='a.out')
    args = parser.parse_args()

    # load the program from disk and form the
    # simulated address space and cpu
    m = load_elf(args.executable)

    # disassemble the entire text segment
    instructions = {}
    for pc in range(m.text_start, m.text_end, 4):
        inst = m.load_instruction(pc)
        instruction = decode(m, pc, inst)
        instructions[pc] = instruction
    pair_instructions(m, instructions)

    add_labels(m, instructions)

    if args.mode == 'dasm':
        for pc in range(m.text_start, m.text_end, 4):
            instruction = instructions[pc]
            disasm = f'{instruction.fields[0]:<8}' + ', '.join(instruction.fields[1:])
            if instruction.label is None:
                addr_part = ''
            else:
                addr_part = instruction.label + ':'
            line = f'{addr_part:<20}{disasm:<48}'
            print(line)
        return

    # trace the entire execution
    # for run mode, haev pre_trace echo output as it goes
    # so inputs and outputs are correctly interleved
    sequence = pre_trace(m, instructions, args.mode=='run')

    if args.mode == 'trace':
        for (instruction, effects) in sequence:
            for line in render_line(instruction, effects):
                print(line)

    if args.mode == 'step':
        ui(m, instructions, sequence)

    # should have ended with exit(0)
    (instruction, effects) = sequence[-1]
    if instruction.fields[0] == 'ecall' and effects.other_message is not None:
        parts = re.match(r'exit\((\d+)\)', effects.other_message)
        if parts is not None:
            sys.exit(int(parts[1]))
    print(effects.other_message, file=sys.stderr)
    sys.exit(1)

main()
