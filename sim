#!/usr/bin/env python3

from dataclasses import dataclass, field
import sys
import struct
from typing import Callable, Optional, TypeAlias

MISALIGNED_OKAY = True

class Machine:
    def __init__(self, memory_start: int, memory_end: int, pc_start: int, text_start: int, text_end: int) -> None:
        # allocate memory
        assert(memory_start >= 4096)
        assert(memory_end > memory_start)
        assert(memory_start & 0xfff == 0)
        assert(memory_end & 0xfff == 0)
        self.memory = bytearray(memory_end - memory_start)
        self.memory_start = memory_start
        self.memory_end = memory_end
        self.pc_start = pc_start
        self.text_start = text_start
        self.text_end = text_end
        self.stdout = bytearray()
        self.stdin = bytearray()

        # allocate a stack with a guard page
        self.stack = bytearray(4096)
        self.stack_start = 0x10000000 - 4096
        if self.stack_start < memory_end + 4096:
            self.stack_start = memory_end + 4096
        self.stack_end = self.stack_start + 4096

        # set up cpu state
        self.x = [0] * 32
        self.pc = pc_start
        self.x[2] = self.stack_end

        # set up tracing
        self.old_pc = 0
        self.reads: list[Value] = []
        self.writes: list[Value] = []
        self.undos: list[Value] = []
        self.stdin_delta: Optional[bytes] = None
        self.stdout_delta: Optional[bytes] = None
        self.other_message: Optional[str] = None
        self.terminate = False

    def lb(self, addr: int) -> int:
        if      not (addr >= self.memory_start and addr < self.memory_end) and \
                not (addr >= self.stack_start  and addr < self.stack_end):
            raise Fault(f'Segmentation fault in lb: address is {addr}')
        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+1 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+1 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, True))
        return int.from_bytes(raw, byteorder='little', signed=True)

    def lh(self, addr: int) -> int:
        if not MISALIGNED_OKAY and (addr & 1) != 0:
            raise Fault(f'Bus error in lh: address is {addr}')
        if      not (addr >= self.memory_start and addr+1 < self.memory_end) and \
                not (addr >= self.stack_start  and addr+1 < self.stack_end):
            raise Fault(f'Segmentation fault in lh: address is {addr}')

        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+2 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+2 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, True))
        return int.from_bytes(raw, byteorder='little', signed=True)

    def lw(self, addr: int) -> int:
        if not MISALIGNED_OKAY and (addr & 3) != 0:
            raise Fault(f'Bus error in lw: address is {addr}')
        if      not (addr >= self.memory_start and addr+3 < self.memory_end) and \
                not (addr >= self.stack_start  and addr+3 < self.stack_end):
            raise Fault(f'Segmentation fault in lw: address is {addr}')

        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+4 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+4 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, True))
        return int.from_bytes(raw, byteorder='little', signed=True)

    def ld(self, addr: int) -> int:
        if not MISALIGNED_OKAY and (addr & 7) != 0:
            raise Fault(f'Bus error in ld: address is {addr}')
        if      not (addr >= self.memory_start and addr+7 < self.memory_end) and \
                not (addr >= self.stack_start  and addr+7 < self.stack_end):
            raise Fault(f'Segmentation fault in ld: address is {addr}')

        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+8 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+8 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, True))
        return int.from_bytes(raw, byteorder='little', signed=True)

    def lbu(self, addr: int) -> int:
        if      not (addr >= self.memory_start and addr < self.memory_end) and \
                not (addr >= self.stack_start  and addr < self.stack_end):
            raise Fault(f'Segmentation fault in lbu: address is {addr}')

        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+1 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+1 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, False))
        return int.from_bytes(raw, byteorder='little', signed=False)

    def lhu(self, addr: int) -> int:
        if not MISALIGNED_OKAY and (addr & 1) != 0:
            raise Fault(f'Bus error in lhu: address is {addr}')
        if      not (addr >= self.memory_start and addr+1 < self.memory_end) and \
                not (addr >= self.stack_start  and addr+1 < self.stack_end):
            raise Fault(f'Segmentation fault in lhu: address is {addr}')

        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+2 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+2 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, False))
        return int.from_bytes(raw, byteorder='little', signed=False)

    def lwu(self, addr: int) -> int:
        if not MISALIGNED_OKAY and (addr & 3) != 0:
            raise Fault(f'Bus error in lwu: address is {addr}')
        if      not (addr >= self.memory_start and addr+3 < self.memory_end) and \
                not (addr >= self.stack_start  and addr+3 < self.stack_end):
            raise Fault(f'Segmentation fault in lwu: address is {addr}')

        if addr < self.memory_end:
            raw = self.memory[addr - self.memory_start: addr+4 - self.memory_start]
        else:
            raw = self.stack[addr - self.stack_start: addr+4 - self.stack_start]

        self.reads.append(MemoryValue(addr, raw, False))
        return int.from_bytes(raw, byteorder='little', signed=False)

    def sb(self, addr: int, value: int) -> None:
        if      not (addr >= self.memory_start and addr < self.memory_end) and \
                not (addr >= self.stack_start  and addr < self.stack_end):
            raise Fault(f'Segmentation fault in sb: address is {addr}')

        raw = (value & 0xff).to_bytes(1, byteorder='little', signed=False)
        if addr < self.memory_end:
            old = self.memory[addr - self.memory_start: addr+1 - self.memory_start]
            for (i, b) in enumerate(raw):
                self.memory[addr+i - self.memory_start] = b
        else:
            old = self.stack[addr - self.stack_start: addr+1 - self.stack_start]
            for (i, b) in enumerate(raw):
                self.stack[addr+i - self.stack_start] = b

        self.writes.append(MemoryValue(addr, raw, False))
        self.undos.append(MemoryValue(addr, old, False))

    def sh(self, addr: int, value: int) -> None:
        if not MISALIGNED_OKAY and (addr & 1) != 0:
            raise Fault(f'Bus error in sh: address is {addr}')
        if      not (addr >= self.memory_start and addr+1 < self.memory_end) and \
                not (addr >= self.stack_start  and addr+1 < self.stack_end):
            raise Fault(f'Segmentation fault in sh: address is {addr}')

        raw = (value & 0xffff).to_bytes(2, byteorder='little', signed=False)
        self.writes.append(MemoryValue(addr, raw, False))

        if addr < self.memory_end:
            old = self.memory[addr - self.memory_start: addr+2 - self.memory_start]
            for (i, b) in enumerate(raw):
                self.memory[addr+i - self.memory_start] = b
        else:
            old = self.stack[addr - self.stack_start: addr+2 - self.stack_start]
            for (i, b) in enumerate(raw):
                self.stack[addr+i - self.stack_start] = b

        self.writes.append(MemoryValue(addr, raw, False))
        self.undos.append(MemoryValue(addr, old, False))

    def sw(self, addr: int, value: int) -> None:
        if not MISALIGNED_OKAY and (addr & 3) != 0:
            raise Fault(f'Bus error in sw: address is {addr}')
        if      not (addr >= self.memory_start and addr+3 < self.memory_end) and \
                not (addr >= self.stack_start  and addr+3 < self.stack_end):
            raise Fault(f'Segmentation fault in sw: address is {addr}')

        raw = (value & 0xffffffff).to_bytes(4, byteorder='little', signed=False)
        if addr < self.memory_end:
            old = self.memory[addr - self.memory_start: addr+4 - self.memory_start]
            for (i, b) in enumerate(raw):
                self.memory[addr+i - self.memory_start] = b
        else:
            old = self.stack[addr - self.stack_start: addr+4 - self.stack_start]
            for (i, b) in enumerate(raw):
                self.stack[addr+i - self.stack_start] = b

        self.writes.append(MemoryValue(addr, raw, False))
        self.undos.append(MemoryValue(addr, old, False))

    def sd(self, addr: int, value: int) -> None:
        if not MISALIGNED_OKAY and (addr & 7) != 0:
            raise Fault(f'Bus error in sd: address is {addr}')
        if      not (addr >= self.memory_start and addr+7 < self.memory_end) and \
                not (addr >= self.stack_start  and addr+7 < self.stack_end):
            raise Fault(f'Segmentation fault in sd: address is {addr}')

        raw = value.to_bytes(8, byteorder='little', signed=True)
        if addr < self.memory_end:
            old = self.memory[addr - self.memory_start: addr+8 - self.memory_start]
            for (i, b) in enumerate(raw):
                self.memory[addr+i - self.memory_start] = b
        else:
            old = self.stack[addr - self.stack_start: addr+8 - self.stack_start]
            for (i, b) in enumerate(raw):
                self.stack[addr+i - self.stack_start] = b

        self.writes.append(MemoryValue(addr, raw, False))
        self.undos.append(MemoryValue(addr, old, False))

    def load_instruction(self, addr: int) -> int:
        if not MISALIGNED_OKAY and (addr & 3) != 0:
            raise Fault(f'Bus error in load_instruction: address is {addr}')
        if not (addr >= self.memory_start and addr+3 < self.memory_end):
            raise Fault(f'Segmentation fault in load_instruction: address is {addr}')

        raw = self.memory[addr - self.memory_start: addr+4 - self.memory_start]
        return int.from_bytes(raw, byteorder='little', signed=True)

    def get(self, reg: int) -> int:
        if reg != 0:
            self.reads.append(RegisterValue(reg, self.x[reg]))
        return self.x[reg]

    def set(self, reg: int, value: int) -> None:
        # zero register never changes
        if reg != 0:
            self.writes.append(RegisterValue(reg, clip(value)))
            self.undos.append(RegisterValue(reg, self.x[reg]))
            self.x[reg] = clip(value)

    def set32(self, reg: int, value: int) -> None:
        # zero register never changes
        if reg != 0:
            self.writes.append(RegisterValue(reg, clip32(value)))
            self.undos.append(RegisterValue(reg, self.x[reg]))
            self.x[reg] = clip32(value)

    def set_pc(self, value: int) -> None:
        self.old_pc = self.pc
        self.pc = clip(value)
        if self.pc & 3 != 0:
            raise Fault(f'Bus error: pc is {self.pc}')

    def gather_effects(self) -> 'Effects':
        e = Effects((self.old_pc, self.pc),
            self.reads, self.writes, self.undos,
            self.stdin_delta, self.stdout_delta,
            self.other_message, self.terminate)
        self.reads = []
        self.writes = []
        self.undos = []
        self.stdin_delta = None
        self.stdout_delta = None
        self.other_message = None
        self.terminate = False
        return e

@dataclass
class Instruction:
    address: int
    instruction: int
    mnemonic: str
    operands: tuple[str, ...]
    execute: Callable[[Machine], None]
    static_target: Optional[int] = None
    return_target: Optional[int] = None
    fallthrough: bool = True
    label: Optional[str] = None
    is_target: bool = False
    base_instructions: Optional[tuple['Instruction']] = None

class Fault(Exception):
    def __init__(self, msg: str):
        self.msg = msg

@dataclass
class MemoryValue:
    address: int
    value: bytes
    signed: bool

@dataclass
class RegisterValue:
    register: int
    value: int

Value: TypeAlias = MemoryValue | RegisterValue

@dataclass
class Effects:
    # pc: old value, new value
    pc: tuple[int, int]
    reads: list[Value]
    writes: list[Value]
    undos: list[Value]
    stdin: Optional[bytes]
    stdout: Optional[bytes]
    other_message: Optional[str]
    terminate: bool

def roll_forward(m: Machine, e: Effects) -> None:
    match e.pc[1]:
        case None: pass
        case new_pc: m.set_pc(new_pc)
    for w in e.writes:
        match w:
            case RegisterValue(rd, val):
                m.set(rd, val)
            case MemoryValue(address, val, signed):
                if len(val) == 1:
                    m.sb(address, val)
                elif len(val) == 2:
                    m.sh(address, val)
                elif len(val) == 4:
                    m.sw(address, val)
                elif len(val) == 8:
                    m.sd(address, val)
                else:
                    assert(False)

def report_effects(e: Effects) -> str:
    parts = []
    for elt in e.writes:
        match elt:
            case RegisterValue(rd, val):
                parts.append(f'{r[rd]} <- {val}')
            case MemoryValue(address, val, signed):
                n = int.from_bytes(val, byteorder='little', signed=signed)
                parts.append(f'({address}) <- {n}')
    for elt in e.reads:
        match elt:
            case RegisterValue(rs, val):
                pass
            case MemoryValue(address, size, val):
                parts.append(f'({address})')
    if e.pc[1] != e.pc[0] + 4:
        parts.append(f'pc <- {e.pc[1]}')
    if e.other_message is not None:
        parts.append(e.other_message)
    if len(parts) == 0:
        return '--'
    else:
        return ', '.join(parts)

# misc helpers
def print32(s: str) -> None:
    print(f'{s:<32}', end='')

def unsigned(i: int) -> int:
    return i&0xffffffffffffffff

def unsigned32(i: int) -> int:
    return i&0x00000000ffffffff

maxint = (1<<63) - 1
def clip(i: int) -> int:
    if -maxint - 1 <= i <= maxint:
        return i
    return (i + (maxint+1)) % (2 * (maxint+1)) - maxint - 1

maxint32 = (1<<31) - 1
def clip32(i: int) -> int:
    if -maxint32 - 1 <= i <= maxint32:
        return i
    return (i + (maxint32+1)) % (2 * (maxint32+1)) - maxint32 - 1

def load_elf(filename: str) -> Machine:
    with open(filename, mode='rb') as fp:
        raw = fp.read()

        # unpack the elf header
        (
            e_ident_mag,
            e_ident_class, e_ident_data, e_ident_version, e_ident_osabi,
            e_ident_abiversion,

            e_type, e_machine, e_version, e_entry,

            e_phoff, e_shoff,

            e_flags, e_ehsize, e_phentsize, e_phnum, e_shentsize, e_shnum, e_shstrndx
        ) = struct.unpack('<4s5B7x'+'2HIQ'+'2Q'+'I6H', raw[:0x40])
        
        # sanity check everything
        assert(e_ident_mag == b'\x7fELF')       # magic number
        assert(e_ident_class == 2)              # 64 bit
        assert(e_ident_data == 1)               # little endian
        assert(e_ident_version == 1)            # version 1 format
        assert(e_ident_osabi == 0)              # System V ABI

        assert(e_type == 2)                     # executable
        assert(e_machine == 0xf3)               # RISC-V
        assert(e_version == 1)                  # ELF version 1

        assert(e_phoff == 0x40)                 # start of program headers
        assert(e_ehsize == 0x40)                # size of elf header
        assert(e_phentsize == 0x38)             # size of program header entry
        assert(e_phnum >= 1)                    # number of program header entries

        # first pass--find how big the VM footprint is
        memory_start, memory_end = 0, 0
        for i in range(e_phnum):
            # unpack the program header
            #print('unpacking program header')
            start = e_phoff + e_phentsize*i
            (
                p_type, p_flags, p_offset, p_vaddr, p_paddr, p_filesz, p_memsz, p_align
            ) = struct.unpack('<2I6Q', raw[start:start+e_phentsize])

            if p_type != 1:
                continue
            assert(p_vaddr >= 0)
            #print(f'found section at {p_vaddr} + {p_memsz}')
            if memory_end == 0 or p_vaddr < memory_start:
                memory_start = p_vaddr
            if p_vaddr + p_memsz > memory_end:
                memory_end = p_vaddr + p_memsz

        # get the section header strings
        i = e_shstrndx
        start = e_shoff + e_shentsize*i
        (
            sh_name, sh_type, sh_flags, sh_addr, sh_offset, sh_size,
            sh_link, sh_info, sh_addralign, sh_entsize
        ) = struct.unpack('<2I4Q2I2Q', raw[start:start+e_shentsize])

        # unpack the strings, keyed by offset
        sh_strs = {}
        sh_str_raw = raw[sh_offset:sh_offset + sh_size]
        start = 0
        for (i, b) in enumerate(sh_str_raw):
            if b == 0:
                sh_strs[start] = sh_str_raw[start:i].decode()
                start = i+1
        
        text_start, text_end = 0, 0
        # read the section headers
        for i in range(e_shnum):
            # unpack the section header
            start = e_shoff + e_shentsize*i
            (
                sh_name, sh_type, sh_flags, sh_addr, sh_offset, sh_size,
                sh_link, sh_info, sh_addralign, sh_entsize
            ) = struct.unpack('<2I4Q2I2Q', raw[start:start+e_shentsize])

            #print(f'{i}: name: {sh_strs[sh_name]}. type: {hex(sh_type)}')
            if sh_strs[sh_name] == '.text' and sh_flags & 4 != 0:
                assert(text_start == 0 and text_end == 0)
                text_start, text_end = sh_addr, sh_addr + sh_size

        #print(f'memory_start: {memory_start}, memory_end: {memory_end}')

        # round to page boundaries at both ends
        memory_start &= ~4095
        memory_end = (memory_end + 4095) & ~4095

        assert(text_start != 0 and text_end != 0)
        assert(text_start <= e_entry < text_end)

        # allocate a page of stack
        #print(f'allocated {(memory_end - memory_start) // 1024}k address space from 0x{memory_start:x} to 0x{memory_end:x} (not including 4k stack)')

        # allocate address space
        m = Machine(memory_start, memory_end, e_entry, text_start, text_end)

        # second pass--load the segments
        for i in range(e_phnum):
            # unpack the program header
            #print(f'unpacking program header {i+1}')
            start = e_phoff + e_phentsize*i
            (
                p_type, p_flags, p_offset, p_vaddr, p_paddr, p_filesz, p_memsz, p_align
            ) = struct.unpack('<2I6Q', raw[start:start+e_phentsize])

            if p_type != 1:
                #print('    skipping non-loadable segment')
                continue
            #print(f'    loading segment from offset 0x{p_offset:x} with size 0x{p_filesz:x}')
            #print(f'    into virtual address 0x{p_vaddr:x} with size 0x{p_memsz:x}')

            for i in range(p_filesz):
                m.sb(p_vaddr + i, raw[p_offset + i])

        # m has been recording memory write effects, so reset it
        m.gather_effects()
        return m

# instruction decoders
def get_funct3(inst: int) -> int:
    return (inst>>12) & 0x07

def get_rd(inst: int) -> int:
    return (inst>>7) & 0x1f

def get_rs1(inst: int) -> int:
    return (inst>>15) & 0x1f

def get_rs2(inst: int) -> int:
    return (inst>>20) & 0x1f

def get_imm_i(inst: int) -> int:
    return inst >> 20

def get_imm_s(inst: int) -> int:
    imm =  (inst >> 20) & ~0x0000001f
    imm |= (inst >> 7)  &  0x0000001f
    return imm

def get_imm_b(inst: int) -> int:
    imm =  (inst >> 20) & ~0x00000fff
    imm |= (inst << 4)  &  0x00000800
    imm |= (inst >> 20) &  0x000007e0
    imm |= (inst >> 7)  &  0x0000001e
    return imm

def get_imm_u(inst: int) -> int:
    return inst & ~0x00000fff

def get_imm_j(inst: int) -> int:
    imm =  (inst >> 11) & ~0x000fffff
    imm |=  inst        &  0x000ff000
    imm |= (inst >> 9)  &  0x00000800
    imm |= (inst >> 20) &  0x000007e0
    imm |= (inst >> 20) &  0x0000001e
    return imm

def get_funct7(inst: int) -> int:
    return inst >> 25

r = [
    'zero', 'ra', 'sp', 'gp', 'tp', 't0', 't1', 't2',
    's0', 's1', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5',
    'a6', 'a7', 's2', 's3', 's4', 's5', 's6', 's7',
    's8', 's9', 's10', 's11', 't3', 't4', 't5', 't6',
    'zero', 'ra', 'sp', 'gp', 'tp', 't0', 't1', 't2',
    's0', 's1', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5',
    'a6', 'a7', 's2', 's3', 's4', 's5', 's6', 's7',
    's8', 's9', 's10', 's11', 't3', 't4', 't5', 't6',
]

def decode(address: int, inst: int) -> Instruction:
    # divide the instructions up according the main instruction opcode
    # then call a specialized function for each opcode to do the rest
    opcode = inst & 0x7f
    match opcode:
        # lui
        case 0x37:
            return decode_lui(address, inst, get_rd(inst), get_imm_u(inst))

        # auipc
        case 0x17:
            return decode_auipc(address, inst, get_rd(inst), get_imm_u(inst))

        # jal
        case 0x6f:
            return decode_jal(address, inst, get_rd(inst), get_imm_j(inst))

        # jalr
        case 0x67:
            return decode_jalr(address, inst, get_funct3(inst), get_rd(inst), get_rs1(inst), get_imm_i(inst))

        # beq, bne, blt, bge, bltu, bgeu
        case 0x63:
            return decode_branches(address, inst, get_funct3(inst), get_rs1(inst), get_rs2(inst), get_imm_b(inst))

        # lb, lh, lw, ld, lbu, lhu, lwu
        case 0x03:
            return decode_load(address, inst, get_funct3(inst), get_rd(inst), get_rs1(inst), get_imm_i(inst))

        # sb, sh, sw, sd
        case 0x23:
            return decode_store(address, inst, get_funct3(inst), get_rs1(inst), get_rs2(inst), get_imm_s(inst))

        # addi, slti, sltiu, xori, ori, andi, slli, srli, srai
        case 0x13:
            return decode_alu_imm(address, inst, get_funct3(inst), get_rd(inst), get_rs1(inst), get_imm_i(inst))

        # addiw, slliw, srliw, sraiw
        case 0x1b:
            return decode_alu_imm_w(address, inst, get_funct3(inst), get_rd(inst), get_rs1(inst), get_imm_i(inst))

        # add, sub, sll, slt, sltu, xor, srl, sra, or, and
        # mul, mulh, mulhsu, mulhu, div, divu, rem, remu
        case 0x33:
            return decode_alu(address, inst, get_funct3(inst), get_rd(inst), get_rs1(inst), get_rs2(inst), get_funct7(inst))

        # addw, subw, sllw, srlw, sraw
        # mulw, divw, remw, remuw 
        case 0x3b:
            return decode_alu_w(address, inst, get_funct3(inst), get_rd(inst), get_rs1(inst), get_rs2(inst), get_funct7(inst))

        # fence
        case 0x0f:
            def execute_fence(m: Machine) -> None:
                # do nothing
                m.set_pc(m.pc + 4)

            return Instruction(address, inst, 'fence', ('*',), execute_fence)

        # ecall, ebreak
        case 0x73:
            if inst == 0x00000073:
                return decode_ecall(address, inst)

                # TODO: if ecall was an exit syscall we quit gracefully
            elif inst == 0x00100073:
                # handle ebreak here--exit
                def execute_ebreak(m: Machine) -> None:
                    m.other_message = 'ebreak'
                    m.terminate = True

                return Instruction(address, inst, 'ebreak', (), execute_ebreak,
                    fallthrough=False)

    raise Fault(f'unknown opcode {opcode}')

def decode_lui(address: int, inst: int, rd: int, imm: int) -> Instruction:
    def execute_lui(m: Machine) -> None:
        m.set(rd, imm)
        m.set_pc(m.pc + 4)
        #print(f'{r[rd]} <- {m.get(rd)}')

    return Instruction(address, inst, 'lui', (r[rd], str(imm)), execute_lui)

def decode_auipc(address: int, inst: int, rd: int, imm: int) -> Instruction:
    def execute_auipc(m: Machine) -> None:
        m.set(rd, m.pc + imm)
        m.set_pc(m.pc + 4)
        #print(f'{r[rd]} <- {m.get(rd)}')

    return Instruction(address, inst, 'auipc', (r[rd], str(imm)), execute_auipc)

def decode_jal(address: int, inst: int, rd: int, imm: int) -> Instruction:
    def execute_jal(m: Machine) -> None:
        m.set(rd, m.pc + 4)
        m.set_pc(m.pc + imm)
        #if rd != 0:
        #    print(f'{r[rd]} <- {m.get(rd)}, ', end='')
        #print(f'pc <- {m.pc}')

    return Instruction(address, inst, 'jal', (r[rd], str(address+imm)), execute_jal,
        static_target=address + imm, fallthrough=False, return_target=None if rd == 0 else address + 4)

def decode_jalr(address: int, inst: int, funct3: int, rd: int, rs1: int, imm: int) -> Instruction:
    if funct3 != 0:
        raise Fault(f'jalr with unknown funct3 value of {funct3}')

    def execute_jalr(m: Machine) -> None:
        # rd and rs1 could be the same, so capture rs1 before setting rd
        rs1_val = m.get(rs1)
        m.set(rd, m.pc + 4)
        m.set_pc((rs1_val + imm) & ~1)

        #if rd != 0:
        #    print(f'{r[rd]} <- {m.get(rd)}, ', end='')
        #print(f'pc <- {m.pc}')

    return Instruction(address, inst, 'jalr', (r[rd], f'{imm}({r[rs1]})'), execute_jalr,
        fallthrough=False, return_target=None if rd == 0 else address + 4)

def decode_branches(address: int, inst: int, funct3: int, rs1: int, rs2: int, imm: int) -> Instruction:
    match funct3:
        case 0:
            def execute_beq(m: Machine) -> None:
                if m.get(rs1) == m.get(rs2):
                    m.set_pc(m.pc + imm)
                    #print(f'pc <- {m.pc}')
                else:
                    m.set_pc(m.pc + 4)
                    #print('--')

            return Instruction(address, inst, 'beq', (r[rs1], r[rs2], str(imm)), execute_beq,
                static_target=address+imm)

        case 1:
            def execute_bne(m: Machine) -> None:
                if m.get(rs1) != m.get(rs2):
                    m.set_pc(m.pc + imm)
                    #print(f'pc <- {m.pc}')
                else:
                    m.set_pc(m.pc + 4)
                    #print('--')

            return Instruction(address, inst, 'bne', (r[rs1], r[rs2], str(imm)), execute_bne,
                static_target=address+imm)

        case 4:
            def execute_blt(m: Machine) -> None:
                if m.get(rs1) < m.get(rs2):
                    m.set_pc(m.pc + imm)
                    #print(f'pc <- {m.pc}')
                else:
                    m.set_pc(m.pc + 4)
                    #print('--')

            return Instruction(address, inst, 'blt', (r[rs1], r[rs2], str(imm)), execute_blt,
                static_target=address+imm)

        case 5:
            def execute_bge(m: Machine) -> None:
                if m.get(rs1) >= m.get(rs2):
                    m.set_pc(m.pc + imm)
                    #print(f'pc <- {m.pc}')
                else:
                    m.set_pc(m.pc + 4)
                    #print('--')

            return Instruction(address, inst, 'bge', (r[rs1], r[rs2], str(imm)), execute_bge,
                static_target=address+imm)

        case 6:
            def execute_bltu(m: Machine) -> None:
                if unsigned(m.get(rs1)) < unsigned(m.get(rs2)):
                    m.set_pc(m.pc + imm)
                    #print(f'pc <- {m.pc}')
                else:
                    m.set_pc(m.pc + 4)
                    #print('--')

            return Instruction(address, inst, 'bltu', (r[rs1], r[rs2], str(imm)), execute_bltu,
                static_target=address+imm)

        case 7:
            def execute_bgeu(m: Machine) -> None:
                if unsigned(m.get(rs1)) >= unsigned(m.get(rs2)):
                    m.set_pc(m.pc + imm)
                    #print(f'pc <- {m.pc}')
                else:
                    m.set_pc(m.pc + 4)
                    #print('--')

            return Instruction(address, inst, 'bgeu', (r[rs1], r[rs2], str(imm)), execute_bgeu,
                static_target=address+imm)

        case _:
            raise Fault(f'branch of unknown type {funct3}')

def decode_load(address: int, inst: int, funct3: int, rd: int, rs1: int, imm: int) -> Instruction:
    match funct3:
        case 0:
            def execute_lb(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.lb(effective_address))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)} ({address})')

            return Instruction(address, inst, 'lb', (r[rd], f'{imm}({r[rs1]})'), execute_lb)

        case 1:
            def execute_lh(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.lh(effective_address))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)} ({address})')

            return Instruction(address, inst, 'lh', (r[rd], f'{imm}({r[rs1]})'), execute_lh)

        case 2:
            def execute_lw(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.lw(effective_address))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)} ({address})')

            return Instruction(address, inst, 'lw', (r[rd], f'{imm}({r[rs1]})'), execute_lw)

        case 3:
            def execute_ld(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.ld(effective_address))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)} ({address})')

            return Instruction(address, inst, 'ld', (r[rd], f'{imm}({r[rs1]})'), execute_ld)

        case 4:
            def execute_lbu(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.lbu(effective_address))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)} ({address})')

            return Instruction(address, inst, 'lbu', (r[rd], f'{imm}({r[rs1]})'), execute_lbu)

        case 5:
            def execute_lhu(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.lhu(effective_address))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)} ({address})')

            return Instruction(address, inst, 'lhu', (r[rd], f'{imm}({r[rs1]})'), execute_lhu)

        case 6:
            def execute_lwu(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.set(rd, m.lwu(effective_address))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)} ({address})')

            return Instruction(address, inst, 'lwu', (r[rd], f'{imm}({r[rs1]})'), execute_lwu)

    raise Fault(f'load instruction of unknown type {funct3}')

def decode_store(address: int, inst: int, funct3: int, rs1: int, rs2: int, imm: int) -> Instruction:
    match funct3:
        case 0:
            def execute_sb(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                val8 = m.get(rs2) & 0xff
                m.sb(effective_address, val8)
                m.set_pc(m.pc + 4)
                #print(f'({effective_address}) <- {val8}')

            return Instruction(address, inst, 'sb', (r[rs2], f'{imm}({r[rs1]})'), execute_sb)

        case 1:
            def execute_sh(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                val16 = m.get(rs2) & 0xffff
                m.sh(effective_address, val16)
                m.set_pc(m.pc + 4)
                #print(f'({effective_address}) <- {val16}')

            return Instruction(address, inst, 'sh', (r[rs2], f'{imm}({r[rs1]})'), execute_sh)

        case 2:
            def execute_sw(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                val32 = m.get(rs2) & 0xffffffff
                m.sw(effective_address, val32)
                m.set_pc(m.pc + 4)
                #print(f'({effective_address}) <- {val32}')

            return Instruction(address, inst, 'sw', (r[rs2], f'{imm}({r[rs1]})'), execute_sw)

        case 3:
            def execute_sd(m: Machine) -> None:
                effective_address = m.get(rs1) + imm
                m.sd(effective_address, m.get(rs2))
                m.set_pc(m.pc + 4)
                #print(f'({effective_address}) <- {m.get(rs2)}')

            return Instruction(address, inst, 'sd', (r[rs2], f'{imm}({r[rs1]})'), execute_sd)

    raise Fault(f'store instruction of unknown type {funct3}')

def decode_alu_imm(address: int, inst: int, funct3: int, rd: int, rs1: int, imm: int) -> Instruction:
    shamt = imm & 0x3f
    imm_high = imm>>6

    match funct3:
        case 0:
            def execute_addi(m: Machine) -> None:
                m.set(rd, m.get(rs1) + imm)
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'addi', (r[rd], r[rs1], str(imm)), execute_addi)

        case 2:
            def execute_slti(m: Machine) -> None:
                m.set(rd, 1 if m.get(rs1) < imm else 0)
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'slti', (r[rd], r[rs1], str(imm)), execute_slti)

        case 3:
            def execute_sltiu(m: Machine) -> None:
                m.set(rd, 1 if unsigned(m.get(rs1)) < unsigned(imm) else 0)
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'sltiu', (r[rd], r[rs1], str(imm)), execute_sltiu)

        case 4:
            def execute_xori(m: Machine) -> None:
                m.set(rd, m.get(rs1) ^ unsigned(imm))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'xori', (r[rd], r[rs1], str(imm)), execute_xori)

        case 6:
            def execute_ori(m: Machine) -> None:
                m.set(rd, m.get(rs1) | imm)
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'ori', (r[rd], r[rs1], str(imm)), execute_ori)

        case 7:
            def execute_andi(m: Machine) -> None:
                m.set(rd, m.get(rs1) & imm)
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'andi', (r[rd], r[rs1], str(imm)), execute_andi)

        case 1:
            if imm_high != 0x00:
                raise Fault(f'immediate mode alu instruction of type {funct3} with unknown subtype {imm_high}')

            def execute_slli(m: Machine) -> None:
                m.set(rd, m.get(rs1) << shamt)
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'slli', (r[rd], r[rs1], str(shamt)), execute_slli)

        case 5:
            if imm_high == 0x00:
                def execute_srli(m: Machine) -> None:
                    m.set(rd, unsigned(m.get(rs1)) >> shamt)
                    m.set_pc(m.pc + 4)
                    #print(f'{r[rd]} <- {m.get(rd)}')

                return Instruction(address, inst, 'srli', (r[rd], r[rs1], str(shamt)), execute_srli)

            elif imm_high == 0x10:
                def execute_srai(m: Machine) -> None:
                    m.set(rd, m.get(rs1) >> shamt)
                    m.set_pc(m.pc + 4)
                    #print(f'{r[rd]} <- {m.get(rd)}')

                return Instruction(address, inst, 'srai', (r[rd], r[rs1], str(shamt)), execute_srai)

            raise Fault(f'immediate mode alu instruction of type {funct3} with unknown subtype {imm_high}')
            
    raise Fault(f'immediate mode alu instruction of unknown type {funct3}')

def decode_alu_imm_w(address: int, inst: int, funct3: int, rd: int, rs1: int, imm: int) -> Instruction:
    shamt = imm & 0x1f
    imm_high = imm>>5

    match funct3:
        case 0:
            def execute_addiw(m: Machine) -> None:
                m.set32(rd, m.get(rs1) + imm)
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'addiw', (r[rd], r[rs1], str(imm)), execute_addiw)

        case 1:
            if imm_high != 0x00:
                raise Fault(f'immediate mode alu w instruction of type {funct3} with unknown subtype {imm_high}')

            def execute_slliw(m: Machine) -> None:
                m.set32(rd, m.get(rs1) << shamt)
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'slliw', (r[rd], r[rs1], str(shamt)), execute_slliw)

        case 5:
            if imm_high == 0x00:
                def execute_srliw(m: Machine) -> None:
                    m.set32(rd, unsigned32(m.get(rs1)) >> shamt)
                    m.set_pc(m.pc + 4)
                    #print(f'{r[rd]} <- {m.get(rd)}')

                return Instruction(address, inst, 'srliw', (r[rd], r[rs1], str(shamt)), execute_srliw)

            elif imm_high == 0x20:
                def execute_sraiw(m: Machine) -> None:
                    m.set32(rd, clip32(m.get(rs1)) >> shamt)
                    m.set_pc(m.pc + 4)
                    #print(f'{r[rd]} <- {m.get(rd)}')

                return Instruction(address, inst, 'sraiw', (r[rd], r[rs1], str(shamt)), execute_sraiw)

            raise Fault(f'immediate mode alu w instruction of type {funct3} with unknown subtype {imm_high}')

    raise Fault(f'immediate mode alu w instruction of unknown type {funct3}')

def decode_alu(address: int, inst: int, funct3: int, rd: int, rs1: int, rs2: int, funct7: int) -> Instruction:
    combined = (funct7 << 8) | funct3

    match combined:
        case 0x0000:
            def execute_add(m: Machine) -> None:
                m.set(rd, m.get(rs1) + m.get(rs2))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'add', (r[rd], r[rs1], r[rs2]), execute_add)

        case 0x2000:
            def execute_sub(m: Machine) -> None:
                m.set(rd, m.get(rs1) - m.get(rs2))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'sub', (r[rd], r[rs1], r[rs2]), execute_sub)

        case 0x0001:
            def execute_sll(m: Machine) -> None:
                m.set(rd, m.get(rs1) << (m.get(rs2) & 0x3f))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'sll', (r[rd], r[rs1], r[rs2]), execute_sll)

        case 0x0002:
            def execute_slt(m: Machine) -> None:
                m.set(rd, 1 if m.get(rs1) < m.get(rs2) else 0)
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'slt', (r[rd], r[rs1], r[rs2]), execute_slt)

        case 0x0003:
            def execute_sltu(m: Machine) -> None:
                m.set(rd, 1 if unsigned(m.get(rs1)) < unsigned(m.get(rs2)) else 0)
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'sltu', (r[rd], r[rs1], r[rs2]), execute_sltu)

        case 0x0004:
            def execute_xor(m: Machine) -> None:
                m.set(rd, m.get(rs1) ^ m.get(rs2))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'xor', (r[rd], r[rs1], r[rs2]), execute_xor)

        case 0x0005:
            def execute_srl(m: Machine) -> None:
                m.set(rd, unsigned(m.get(rs1)) >> (m.get(rs2) & 0x3f))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'srl', (r[rd], r[rs1], r[rs2]), execute_srl)

        case 0x2005:
            def execute_sra(m: Machine) -> None:
                m.set(rd, m.get(rs1) >> (m.get(rs2) & 0x3f))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'sra', (r[rd], r[rs1], r[rs2]), execute_sra)

        case 0x0006:
            def execute_or(m: Machine) -> None:
                m.set(rd, m.get(rs1) | m.get(rs2))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'or', (r[rd], r[rs1], r[rs2]), execute_or)

        case 0x0007:
            def execute_and(m: Machine) -> None:
                m.set(rd, m.get(rs1) & m.get(rs2))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'and', (r[rd], r[rs1], r[rs2]), execute_and)

        case 0x0100:
            def execute_mul(m: Machine) -> None:
                m.set(rd, m.get(rs1) * m.get(rs2))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'mul', (r[rd], r[rs1], r[rs2]), execute_mul)

        case 0x0101:
            def execute_mulh(m: Machine) -> None:
                m.set(rd, (m.get(rs1) * m.get(rs2)) >> 64)
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'mulh', (r[rd], r[rs1], r[rs2]), execute_mulh)

        case 0x0102:
            def execute_mulhsu(m: Machine) -> None:
                m.set(rd, (m.get(rs1) * unsigned(m.get(rs2))) >> 64)
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'mulhsu', (r[rd], r[rs1], r[rs2]), execute_mulhsu)

        case 0x0103:
            def execute_mulhu(m: Machine) -> None:
                m.set(rd, (unsigned(m.get(rs1)) * unsigned(m.get(rs2))) >> 64)
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'mulhu', (r[rd], r[rs1], r[rs2]), execute_mulhu)

        case 0x0104:
            def execute_div(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set(rd, -1)
                else:
                    m.set(rd, int(m.get(rs1) / m.get(rs2)))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'div', (r[rd], r[rs1], r[rs2]), execute_div)

        case 0x0105:
            def execute_divu(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set(rd, -1)
                else:
                    m.set(rd, unsigned(m.get(rs1)) // unsigned(m.get(rs2)))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'divu', (r[rd], r[rs1], r[rs2]), execute_divu)

        case 0x0106:
            def execute_rem(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set(rd, m.get(rs1))
                else:
                    m.set(rd, m.get(rs1) - int(m.get(rs1) / m.get(rs2)) * m.get(rs2))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'rem', (r[rd], r[rs1], r[rs2]), execute_rem)

        case 0x0107:
            def execute_remu(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set(rd, m.get(rs1))
                else:
                    m.set(rd, unsigned(m.get(rs1)) % unsigned(m.get(rs2)))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'remu', (r[rd], r[rs1], r[rs2]), execute_remu)

    raise Fault(f'alu instruction of unknown type {funct3} subtype {funct7}')

def decode_alu_w(address: int, inst: int, funct3: int, rd: int, rs1: int, rs2: int, funct7: int) -> Instruction:
    combined = (funct7 << 8) | funct3

    match combined:
        case 0x0000:
            def execute_addw(m: Machine) -> None:
                m.set32(rd, m.get(rs1) + m.get(rs2))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'addw', (r[rd], r[rs1], r[rs2]), execute_addw)

        case 0x2000:
            def execute_subw(m: Machine) -> None:
                m.set32(rd, m.get(rs1) - m.get(rs2))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'subw', (r[rd], r[rs1], r[rs2]), execute_subw)

        case 0x0001:
            def execute_sllw(m: Machine) -> None:
                m.set32(rd, m.get(rs1) << (m.get(rs2) & 0x1f))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'sllw', (r[rd], r[rs1], r[rs2]), execute_sllw)

        case 0x0005:
            def execute_srlw(m: Machine) -> None:
                m.set32(rd, unsigned32(m.get(rs1)) >> (m.get(rs2) & 0x1f))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'srlw', (r[rd], r[rs1], r[rs2]), execute_srlw)

        case 0x2005:
            def execute_sraw(m: Machine) -> None:
                m.set32(rd, clip32(m.get(rs1)) >> (m.get(rs2) & 0x1f))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'sraw', (r[rd], r[rs1], r[rs2]), execute_sraw)

        case 0x0100:
            def execute_mulw(m: Machine) -> None:
                m.set32(rd, m.get(rs1) * m.get(rs2))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'mulw', (r[rd], r[rs1], r[rs2]), execute_mulw)

        case 0x0104:
            def execute_divw(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set32(rd, -1)
                else:
                    m.set32(rd, int(m.get(rs1) / m.get(rs2)))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'divw', (r[rd], r[rs1], r[rs2]), execute_divw)

        case 0x0105:
            def execute_divuw(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set32(rd, -1)
                else:
                    m.set32(rd, unsigned(m.get(rs1)) // unsigned(m.get(rs2)))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'divuw', (r[rd], r[rs1], r[rs2]), execute_divuw)

        case 0x0106:
            def execute_remw(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set32(rd, m.get(rs1))
                else:
                    m.set32(rd, m.get(rs1) - int(m.get(rs1) / m.get(rs2)) * m.get(rs2))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'remw', (r[rd], r[rs1], r[rs2]), execute_remw)

        case 0x0107:
            def execute_remuw(m: Machine) -> None:
                if m.get(rs2) == 0:
                    m.set32(rd, m.get(rs1))
                else:
                    m.set32(rd, unsigned(m.get(rs1)) % unsigned(m.get(rs2)))
                m.set_pc(m.pc + 4)
                #print(f'{r[rd]} <- {m.get(rd)}')

            return Instruction(address, inst, 'remuw', (r[rd], r[rs1], r[rs2]), execute_remuw)

    raise Fault(f'alu w instruction of unknown type {funct3} subtype {funct7}')


def decode_ecall(address: int, inst: int) -> Instruction:
    def execute_ecall(m: Machine) -> None:
        if m.get(17) == 63:
            # read system call
            m.other_message = f'read({m.get(10)}, {m.get(11)}, {m.get(12)})'
            if m.get(10) != 0:
                raise Fault(f'Invalid file descriptor in read system call: {m.get(10)} but only 0 (stdin) is supported')
            if m.get(12) < 0:
                raise Fault(f'Invalid buffer size in read system call: {m.get(12)}')

            if      m.get(11) >= m.memory_start and m.get(11) + m.get(12) <= m.memory_end or \
                    m.get(11) >= m.stack_start  and m.get(11) + m.get(12) <= m.stack_end:
                read_res = sys.stdin.buffer.read(m.get(12))
                for (i, b) in enumerate(read_res):
                    m.sb(m.get(11) + i, b)
                m.set(10, len(read_res))
                m.stdin_delta = read_res
                m.stdin += read_res
                #print(f'{"":52}{r[10]} <- {m.get(10)}')
                m.set_pc(m.pc + 4)
                return
            else:
                raise Fault(f'Invalid memory range in read system call: {m.get(11)} to {m.get(11)+m.get(12)}')

        if m.get(17) == 64:
            # write system call
            m.other_message = f'write({m.get(10)}, {m.get(11)}, {m.get(12)})'
            if m.get(10) != 1:
                raise Fault(f'Invalid file descriptor in write system call: {m.get(10)} but only 1 (stdout) is supported')
            if m.get(12) < 0:
                raise Fault(f'Invalid buffer size in write system call: {m.get(12)}')

            if      m.get(11) >= m.memory_start and m.get(11) + m.get(12) <= m.memory_end or \
                    m.get(11) >= m.stack_start  and m.get(11) + m.get(12) <= m.stack_end:
                buf = bytearray(m.get(12))
                for i, addr in enumerate(range(m.get(11), m.get(11) + m.get(12))):
                    buf[i] = m.lbu(addr)
                m.set(10, len(buf))
                m.stdout_delta = bytes(buf)
                m.stdout += buf
                #print(f'{"":52}{r[10]} <- {m.get(10)}')
                m.set_pc(m.pc + 4)
                return
            else:
                raise Fault(f'Invalid memory range in write system call: {m.get(11)} to {m.get(11)+m.get(12)}')

        if m.get(17) == 93:
            # exit system call
            m.other_message = f'exit({m.get(10)})'
            m.terminate = True
            return

        # unimplemented
        raise Fault(f'unsupported syscall {m.get(17)}')

    return Instruction(address, inst, 'ecall', (), execute_ecall)

def execute(m: Machine, inst: int) -> bool:
    okay = False

    # print the address and the raw instruction bits
    print(f'{m.pc:6}: {inst&0xffffffff:08x}    ', end='')

    # divide the instructions up according the main instruction opcode
    # then call a specialized function for each opcode to do the rest
    opcode = inst & 0x7f
    match opcode:
        # lui
        case 0x37:
            okay = execute_lui(m, get_rd(inst), get_imm_u(inst))
            m.set_pc(m.pc + 4)

        # auipc
        case 0x17:
            okay = execute_auipc(m, get_rd(inst), get_imm_u(inst))
            m.set_pc(m.pc + 4)

        # jal
        case 0x6f:
            # execute_jal updates the PC
            okay = execute_jal(m, get_rd(inst), get_imm_j(inst))

        # jalr
        case 0x67:
            # execute_jalr updates the PC
            okay = execute_jalr(m, get_funct3(inst), get_rd(inst), get_rs1(inst), get_imm_i(inst))

        # beq, bne, blt, bge, bltu, bgeu
        case 0x63:
            # execute_branches updates the PC
            okay = execute_branches(m, get_funct3(inst), get_rs1(inst), get_rs2(inst), get_imm_b(inst))

        # lb, lh, lw, ld, lbu, lhu, lwu
        case 0x03:
            okay = execute_load(m, get_funct3(inst), get_rd(inst), get_rs1(inst), get_imm_i(inst))
            m.set_pc(m.pc + 4)

        # sb, sh, sw, sd
        case 0x23:
            okay = execute_store(m, get_funct3(inst), get_rs1(inst), get_rs2(inst), get_imm_s(inst))
            m.set_pc(m.pc + 4)

        # addi, slti, sltiu, xori, ori, andi, slli, srli, srai
        case 0x13:
            okay = execute_alu_imm(m, get_funct3(inst), get_rd(inst), get_rs1(inst), get_imm_i(inst))
            m.set_pc(m.pc + 4)

        # addiw, slliw, srliw, sraiw
        case 0x1b:
            okay = execute_alu_imm_w(m, get_funct3(inst), get_rd(inst), get_rs1(inst), get_imm_i(inst))
            m.set_pc(m.pc + 4)

        # add, sub, sll, slt, sltu, xor, srl, sra, or, and
        # mul, mulh, mulhsu, mulhu, div, divu, rem, remu
        case 0x33:
            okay = execute_alu(m, get_funct3(inst), get_rd(inst), get_rs1(inst), get_rs2(inst), get_funct7(inst))
            m.set_pc(m.pc + 4)

        # addw, subw, sllw, srlw, sraw
        # mulw, divw, remw, remuw 
        case 0x3b:
            okay = execute_alu_w(m, get_funct3(inst), get_rd(inst), get_rs1(inst), get_rs2(inst), get_funct7(inst))
            m.set_pc(m.pc + 4)

        # fence
        case 0x0f:
            # ignore this instruction
            print32('fence     *')
            print('--')
            m.set_pc(m.pc + 4)

        # ecall, ebreak
        case 0x73:
            if inst == 0x00000073:
                okay = execute_ecall(m)
                m.set_pc(m.pc + 4)

                # if ecall was an exit syscall we quit gracefully
                return okay
            elif inst == 0x00100073:
                # handle ebreak here--print the instruction and exit
                print('ebreak')
                return False

    if not okay:
        print('unknown instruction')

    return okay

def execute_lui(m: Machine, rd: int, imm: int) -> bool:
    print32(f'lui     {r[rd]}, {imm}')

    m.set(rd, imm)

    print(f'{r[rd]} <- {m.get(rd)}')

    return True

def execute_auipc(m: Machine, rd: int, imm: int) -> bool:
    print32(f'auipc   {r[rd]}, {imm}')

    m.set(rd, m.pc + imm)

    print(f'{r[rd]} <- {m.get(rd)}')

    return True

def execute_jal(m: Machine, rd: int, imm: int) -> bool:
    if rd == 0:
        print32(f'j       {m.pc + imm}')
    elif rd == 1:
        print32(f'call    {m.pc + imm}')
    else:
        print32(f'jal     {r[rd]}, {m.pc + imm}')

    m.set(rd, m.pc + 4)
    m.set_pc(m.pc + imm)

    if rd != 0:
        print(f'{r[rd]} <- {m.get(rd)}, ', end='')
    print(f'pc <- {m.pc}')

    return True

def execute_jalr(m: Machine, funct3: int, rd: int, rs1: int, imm: int) -> bool:
    if funct3 != 0:
        return False

    if rd == 0 and rs1 == 1 and imm == 0:
        print32('ret')
    elif rd == 0 and imm == 0:
        print32(f'jr      {r[rs1]}')
    elif rd == 1 and imm == 0:
        print32(f'jalr    {r[rs1]}')
    elif imm == 0:
        print32(f'jalr    {r[rd]}, ({r[rs1]})')
    else:
        print32(f'jalr    {r[rd]}, {imm}({r[rs1]})')

    # rd and rs1 could be the same, so capture rs1 before setting rd
    rs1_val = m.get(rs1)
    m.set(rd, m.pc + 4)
    m.set_pc((rs1_val + imm) & ~1)

    if rd != 0:
        print(f'{r[rd]} <- {m.get(rd)}, ', end='')
    print(f'pc <- {m.pc}')

    return True

def execute_branches(m: Machine, funct3: int, rs1: int, rs2: int, imm: int) -> bool:
    taken = False

    match funct3:
        case 0:
            if rs2 == 0:
                print32(f'beqz    {r[rs1]}, {imm}')
            else:
                print32(f'beq     {r[rs1]}, {r[rs2]}, {imm}')

            taken = m.get(rs1) == m.get(rs2)

        case 1:
            if rs2 == 0:
                print32(f'bnez    {r[rs1]}, {imm}')
            else:
                print32(f'bne     {r[rs1]}, {r[rs2]}, {imm}')

            taken = m.get(rs1) != m.get(rs2)

        case 4:
            if rs2 == 0:
                print32(f'bltz    {r[rs1]}, {imm}')
            elif rs1 == 0:
                print32(f'bgtz    {r[rs2]}, {imm}')
            else:
                print32(f'blt     {r[rs1]}, {r[rs2]}, {imm}')

            taken = m.get(rs1) < m.get(rs2)

        case 5:
            if rs1 == 0:
                print32(f'blez    {r[rs2]}, {imm}')
            elif rs2 == 0:
                print32(f'bgez    {r[rs1]}, {imm}')
            else:
                print32(f'bge     {r[rs1]}, {r[rs2]}, {imm}')

            taken = m.get(rs1) >= m.get(rs2)

        case 6:
            print32(f'bltu    {r[rs1]}, {r[rs2]}, {imm}')

            taken = unsigned(m.get(rs1)) < unsigned(m.get(rs2))

        case 7:
            print32(f'bgeu    {r[rs1]}, {r[rs2]}, {imm}')

            taken = unsigned(m.get(rs1)) >= unsigned(m.get(rs2))

        case _:
            return False

    if taken:
        m.set_pc(m.pc + imm)
        print(f'pc <- {m.pc}')
    else:
        m.set_pc(m.pc + 4)
        print('--')

    return True

def execute_load(m: Machine, funct3: int, rd: int, rs1: int, imm: int) -> bool:
    match funct3:
        case 0:
            if imm == 0:
                print32(f'lb      {r[rd]}, ({r[rs1]})')
            else:
                print32(f'lb      {r[rd]}, {imm}({r[rs1]})')

            address = m.get(rs1) + imm
            m.set(rd, m.lb(address))

            print(f'{r[rd]} <- {m.get(rd)} ({address})')
            return True

        case 1:
            if imm == 0:
                print32(f'lh      {r[rd]}, ({r[rs1]})')
            else:
                print32(f'lh      {r[rd]}, {imm}({r[rs1]})')

            address = m.get(rs1) + imm
            m.set(rd, m.lh(address))

            print(f'{r[rd]} <- {m.get(rd)} ({address})')
            return True

        case 2:
            if imm == 0:
                print32(f'lw      {r[rd]}, ({r[rs1]})')
            else:
                print32(f'lw      {r[rd]}, {imm}({r[rs1]})')

            address = m.get(rs1) + imm
            m.set(rd, m.lw(address))

            print(f'{r[rd]} <- {m.get(rd)} ({address})')
            return True

        case 3:
            if imm == 0:
                print32(f'ld      {r[rd]}, ({r[rs1]})')
            else:
                print32(f'ld      {r[rd]}, {imm}({r[rs1]})')

            address = m.get(rs1) + imm
            m.set(rd, m.ld(address))

            print(f'{r[rd]} <- {m.get(rd)} ({address})')
            return True

        case 4:
            if imm == 0:
                print32(f'lbu     {r[rd]}, ({r[rs1]})')
            else:
                print32(f'lbu     {r[rd]}, {imm}({r[rs1]})')

            address = m.get(rs1) + imm
            m.set(rd, m.lbu(address))

            print(f'{r[rd]} <- {m.get(rd)} ({address})')
            return True

        case 5:
            if imm == 0:
                print32(f'lhu     {r[rd]}, ({r[rs1]})')
            else:
                print32(f'lhu     {r[rd]}, {imm}({r[rs1]})')

            address = m.get(rs1) + imm
            m.set(rd, m.lhu(address))

            print(f'{r[rd]} <- {m.get(rd)} ({address})')
            return True

        case 6:
            if imm == 0:
                print32(f'lwu     {r[rd]}, ({r[rs1]})')
            else:
                print32(f'lwu     {r[rd]}, {imm}({r[rs1]})')

            address = m.get(rs1) + imm
            m.set(rd, m.lwu(address))

            print(f'{r[rd]} <- {m.get(rd)} ({address})')
            return True

    return False

def execute_store(m: Machine, funct3: int, rs1: int, rs2: int, imm: int) -> bool:
    match funct3:
        case 0:
            if imm == 0:
                print32(f'sb      {r[rs2]}, ({r[rs1]})')
            else:
                print32(f'sb      {r[rs2]}, {imm}({r[rs1]})')

            address = m.get(rs1) + imm
            val8 = m.get(rs2) & 0xff
            m.sb(address, val8)

            print(f'({address}) <- {val8}')
            return True

        case 1:
            if imm == 0:
                print32(f'sh      {r[rs2]}, ({r[rs1]})')
            else:
                print32(f'sh      {r[rs2]}, {imm}({r[rs1]})')

            address = m.get(rs1) + imm
            val16 = m.get(rs2) & 0xffff
            m.sh(address, val16)

            print(f'({address}) <- {val16}')
            return True

        case 2:
            if imm == 0:
                print32(f'sw      {r[rs2]}, ({r[rs1]})')
            else:
                print32(f'sw      {r[rs2]}, {imm}({r[rs1]})')

            address = m.get(rs1) + imm
            val32 = m.get(rs2) & 0xffffffff
            m.sw(address, val32)

            print(f'({address}) <- {val32}')
            return True

        case 3:
            if imm == 0:
                print32(f'sd      {r[rs2]}, ({r[rs1]})')
            else:
                print32(f'sd      {r[rs2]}, {imm}({r[rs1]})')

            address = m.get(rs1) + imm
            m.sd(address, m.get(rs2))

            print(f'({address}) <- {m.get(rs2)}')
            return True

    return False

def execute_alu_imm(m: Machine, funct3: int, rd: int, rs1: int, imm: int) -> bool:
    shamt = imm & 0x3f
    imm_high = imm>>6

    match funct3:
        case 0:
            if rd == 0 and rs1 == 0 and imm == 0:
                print32('nop')
            elif rs1 == 0:
                print32(f'li      {r[rd]}, {imm}')
            elif imm == 0:
                print32(f'mv      {r[rd]}, {r[rs1]}')
            else:
                print32(f'addi    {r[rd]}, {r[rs1]}, {imm}')

            m.set(rd, m.get(rs1) + imm)

            if rd == 0:
                print('--')
            else:
                print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 2:
            print32(f'slti    {r[rd]}, {r[rs1]}, {imm}')

            m.set(rd, 1 if m.get(rs1) < imm else 0)

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 3:
            if imm == 1:
                print32(f'seqz    {r[rd]}, {r[rs1]}')
            else:
                print32(f'sltiu   {r[rd]}, {r[rs1]}, {imm}')

            m.set(rd, 1 if unsigned(m.get(rs1)) < unsigned(imm) else 0)

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 4:
            if imm == -1:
                print32(f'not     {r[rd]}, {r[rs1]}')
            else:
                print32(f'xori    {r[rd]}, {r[rs1]}, {imm}')

            m.set(rd, m.get(rs1) ^ unsigned(imm))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 6:
            print32(f'ori     {r[rd]}, {r[rs1]}, {imm}')

            m.set(rd, m.get(rs1) | imm)

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 7:
            print32(f'andi    {r[rd]}, {r[rs1]}, {imm}')

            m.set(rd, m.get(rs1) & imm)

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 1:
            if imm_high != 0x00:
                return False

            print32(f'slli    {r[rd]}, {r[rs1]}, {shamt}')

            m.set(rd, m.get(rs1) << shamt)

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 5:
            if imm_high == 0x00:
                print32(f'srli    {r[rd]}, {r[rs1]}, {shamt}')

                m.set(rd, unsigned(m.get(rs1)) >> shamt)

                print(f'{r[rd]} <- {m.get(rd)}')
                return True
            elif imm_high == 0x10:
                print32(f'srai    {r[rd]}, {r[rs1]}, {shamt}')

                m.set(rd, m.get(rs1) >> shamt)

                print(f'{r[rd]} <- {m.get(rd)}')
                return True
            return False
            
    return False

def execute_alu_imm_w(m: Machine, funct3: int, rd: int, rs1: int, imm: int) -> bool:
    shamt = imm & 0x1f
    imm_high = imm>>5

    match funct3:
        case 0:
            if rd == 0 and rs1 == 0 and imm == 0:
                print32('nop')
            elif rs1 == 0:
                print32(f'li      {r[rd]}, {imm}')
            else:
                print32(f'addiw   {r[rd]}, {r[rs1]}, {imm}')

            m.set32(rd, m.get(rs1) + imm)

            if rd == 0:
                print('--')
            else:
                print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 1:
            if imm_high != 0x00:
                return False

            print32(f'slliw   {r[rd]}, {r[rs1]}, {shamt}')

            m.set32(rd, m.get(rs1) << shamt)

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 5:
            if imm_high == 0x00:
                print32(f'srliw   {r[rd]}, {r[rs1]}, {shamt}')

                m.set32(rd, unsigned32(m.get(rs1)) >> shamt)

                print(f'{r[rd]} <- {m.get(rd)}')
                return True
            elif imm_high == 0x20:
                print32(f'sraiw   {r[rd]}, {r[rs1]}, {shamt}')

                m.set32(rd, clip32(m.get(rs1)) >> shamt)

                print(f'{r[rd]} <- {m.get(rd)}')
                return True
            return False

    return False

def execute_alu(m: Machine, funct3: int, rd: int, rs1: int, rs2: int, funct7: int) -> bool:
    combined = (funct7 << 8) | funct3

    match combined:
        case 0x0000:
            print32(f'add     {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set(rd, m.get(rs1) + m.get(rs2))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x2000:
            if rs1 == 0:
                print32(f'neg     {r[rd]}, {r[rs2]}')
            else:
                print32(f'sub     {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set(rd, m.get(rs1) - m.get(rs2))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0001:
            print32(f'sll     {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set(rd, m.get(rs1) << (m.get(rs2) & 0x3f))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0002:
            if rs2 == 0:
                print32(f'sltz    {r[rd]}, {r[rs1]}')
            elif rs1 == 0:
                print32(f'sgtz    {r[rd]}, {r[rs2]}')
            else:
                print32(f'slt     {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set(rd, 1 if m.get(rs1) < m.get(rs2) else 0)

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0003:
            if rs1 == 0:
                print32(f'snez    {r[rd]}, {r[rs2]}')
            else:
                print32(f'sltu    {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set(rd, 1 if unsigned(m.get(rs1)) < unsigned(m.get(rs2)) else 0)

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0004:
            print32(f'xor     {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set(rd, m.get(rs1) ^ m.get(rs2))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0005:
            print32(f'srl     {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set(rd, unsigned(m.get(rs1)) >> (m.get(rs2) & 0x3f))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x2005:
            print32(f'sra     {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set(rd, m.get(rs1) >> (m.get(rs2) & 0x3f))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0006:
            print32(f'or      {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set(rd, m.get(rs1) | m.get(rs2))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0007:
            print32(f'and     {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set(rd, m.get(rs1) & m.get(rs2))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0100:
            print32(f'mul     {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set(rd, m.get(rs1) * m.get(rs2))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0101:
            print32(f'mulh    {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set(rd, (m.get(rs1) * m.get(rs2)) >> 64)

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0102:
            print32(f'mulhsu  {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set(rd, (m.get(rs1) * unsigned(m.get(rs2))) >> 64)

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0103:
            print32(f'mulhu   {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set(rd, (unsigned(m.get(rs1)) * unsigned(m.get(rs2))) >> 64)

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0104:
            print32(f'div     {r[rd]}, {r[rs1]}, {r[rs2]}')

            if m.get(rs2) == 0:
                m.set(rd, -1)
            else:
                m.set(rd, int(m.get(rs1) / m.get(rs2)))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0105:
            print32(f'divu    {r[rd]}, {r[rs1]}, {r[rs2]}')

            if m.get(rs2) == 0:
                m.set(rd, -1)
            else:
                m.set(rd, unsigned(m.get(rs1)) // unsigned(m.get(rs2)))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0106:
            print32(f'rem     {r[rd]}, {r[rs1]}, {r[rs2]}')

            if m.get(rs2) == 0:
                m.set(rd, m.get(rs1))
            else:
                m.set(rd, m.get(rs1) - int(m.get(rs1) / m.get(rs2)) * m.get(rs2))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0107:
            print32(f'remu    {r[rd]}, {r[rs1]}, {r[rs2]}')

            if m.get(rs2) == 0:
                m.set(rd, m.get(rs1))
            else:
                m.set(rd, unsigned(m.get(rs1)) % unsigned(m.get(rs2)))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

    return False

def execute_alu_w(m: Machine, funct3: int, rd: int, rs1: int, rs2: int, funct7: int) -> bool:
    combined = (funct7 << 8) | funct3

    match combined:
        case 0x0000:
            print32(f'addw    {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set32(rd, m.get(rs1) + m.get(rs2))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x2000:
            print32(f'subw    {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set32(rd, m.get(rs1) - m.get(rs2))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0001:
            print32(f'sllw    {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set32(rd, m.get(rs1) << (m.get(rs2) & 0x1f))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0005:
            print32(f'srlw    {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set32(rd, unsigned32(m.get(rs1)) >> (m.get(rs2) & 0x1f))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x2005:
            print32(f'sraw    {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set32(rd, clip32(m.get(rs1)) >> (m.get(rs2) & 0x1f))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0100:
            print32(f'mulw    {r[rd]}, {r[rs1]}, {r[rs2]}')

            m.set32(rd, m.get(rs1) * m.get(rs2))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0104:
            print32(f'divw    {r[rd]}, {r[rs1]}, {r[rs2]}')

            if m.get(rs2) == 0:
                m.set32(rd, -1)
            else:
                m.set32(rd, int(m.get(rs1) / m.get(rs2)))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0105:
            print32(f'divuw   {r[rd]}, {r[rs1]}, {r[rs2]}')

            if m.get(rs2) == 0:
                m.set32(rd, -1)
            else:
                m.set32(rd, unsigned(m.get(rs1)) // unsigned(m.get(rs2)))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0106:
            print32(f'remw    {r[rd]}, {r[rs1]}, {r[rs2]}')

            if m.get(rs2) == 0:
                m.set32(rd, m.get(rs1))
            else:
                m.set32(rd, m.get(rs1) - int(m.get(rs1) / m.get(rs2)) * m.get(rs2))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

        case 0x0107:
            print32(f'remuw   {r[rd]}, {r[rs1]}, {r[rs2]}')

            if m.get(rs2) == 0:
                m.set32(rd, m.get(rs1))
            else:
                m.set32(rd, unsigned(m.get(rs1)) % unsigned(m.get(rs2)))

            print(f'{r[rd]} <- {m.get(rd)}')
            return True

    return False


def execute_ecall(m: Machine) -> bool:
    print32('ecall')

    if m.get(17) == 63:
        # read system call
        print(f'read({m.get(10)}, {m.get(11)}, {m.get(12)})')
        if m.get(10) != 0:
            raise Fault(f'Invalid file descriptor in read system call: {m.get(10)} but only 0 (stdin) is supported')
        if m.get(12) < 0:
            raise Fault(f'Invalid buffer size in read system call: {m.get(12)}')

        if      m.get(11) >= m.memory_start and m.get(11) + m.get(12) <= m.memory_end or \
                m.get(11) >= m.stack_start  and m.get(11) + m.get(12) <= m.stack_end:
            sys.stdout.flush()
            read_res = sys.stdin.buffer.read(m.get(12))
            for (i, b) in enumerate(read_res):
                m.sb(m.get(11) + i, b)
            m.set(10, len(read_res))
            print(f'{"":52}{r[10]} <- {m.get(10)}')
            return True
        else:
            raise Fault(f'Invalid memory range in read system call: {m.get(11)} to {m.get(11)+m.get(12)}')

    if m.get(17) == 64:
        # write system call
        print(f'write({m.get(10)}, {m.get(11)}, {m.get(12)})')
        if m.get(10) != 1:
            raise Fault(f'Invalid file descriptor in write system call: {m.get(10)} but only 1 (stdout) is supported')
        if m.get(12) < 0:
            raise Fault(f'Invalid buffer size in write system call: {m.get(12)}')

        if      m.get(11) >= m.memory_start and m.get(11) + m.get(12) <= m.memory_end or \
                m.get(11) >= m.stack_start  and m.get(11) + m.get(12) <= m.stack_end:
            buf = bytearray(m.get(12))
            for i, addr in enumerate(range(m.get(11), m.get(11) + m.get(12))):
                buf[i] = m.lbu(addr)
            sys.stdout.flush()
            write_res = sys.stdout.buffer.write(buf)
            sys.stdout.flush()
            m.set(10, write_res)
            print(f'{"":52}{r[10]} <- {m.get(10)}')
            return True
        else:
            raise Fault(f'Invalid memory range in write system call: {m.get(11)} to {m.get(11)+m.get(12)}')

    if m.get(17) == 93:
        # exit system call
        print(f'exit({m.get(10)})')
        sys.stdout.flush()
        return False

    # unimplemented
    print(f'unsupported syscall {m.get(17)}')
    sys.stdout.flush()
    return False

def main() -> None:
    # default to 'a.out' as the executable file,
    # or let the user specify a name on the command line
    if len(sys.argv) == 1:
        filename = 'a.out'
    elif len(sys.argv) == 2:
        filename = sys.argv[1]
    else:
        print(f'Usage: {sys.argv[0]} <filename>', file=sys.stderr)
        sys.exit(1)

    # load the program from disk and form the
    # simulated address space and cpu
    m = load_elf(filename)

    # disassemble the entire text segment
    text = {}
    for pc in range(m.text_start, m.text_end, 4):
        inst = m.load_instruction(pc)
        #print(f'{pc:6}: {inst&0xffffffff:08x}    ', end='')
        instruction = decode(pc, inst)
        #s = ', '.join(instruction.operands)
        #print32(f'{instruction.mnemonic:<8}{s}')
        #print()

        text[pc] = instruction

    # main loop
    sequence = []
    while True:
        # fetch the next instruction
        instruction = text[m.pc]
        try:
            instruction.execute(m)
        except Fault as e:
            m.other_message = e.msg
            m.terminate = True
        e = m.gather_effects()
        sequence.append( (instruction, e) )
        if e.terminate:
            break

    for (instruction, effects) in sequence:
        disasm = f'{instruction.mnemonic:<8}' + ', '.join(instruction.operands)
        changed = report_effects(effects)
        line = f'{instruction.address:6}: {instruction.instruction&0xffffffff:08x}    {disasm:<32}{changed}'
        print(line)

    if len(m.stdin) > 0:
        #print('stdin:')
        #print(m.stdin.decode())
        pass

    if len(m.stdout) > 0:
        print(m.stdout.decode(), end='')

main()
