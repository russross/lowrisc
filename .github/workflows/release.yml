# .github/workflows/release.yml
# Workflow name
name: Release Build and Publish

# Controls when the workflow will run
on:
  push:
    tags:
      - 'v*.*.*' # Trigger on tags like v1.0.0, v2.3.4 etc.

# Permissions needed by the workflow
permissions:
  contents: write # Needed to create releases, upload release assets

# Default settings for all jobs
defaults:
  run:
    shell: bash

# Environment variables available to all jobs
env:
  # Fail the build if there are warnings
  RUSTFLAGS: --deny warnings
  # Set the binary name of your crate here
  BINARY_NAME: "lowrisc"

jobs:
  # Optional: Job to check if the tag is a pre-release or full release
  check_release_type:
    name: Check Release Type
    runs-on: ubuntu-latest
    outputs:
      is_prerelease: ${{ steps.check_tag.outputs.is_prerelease }}
      tag_name: ${{ steps.check_tag.outputs.tag_name }}
    steps:
      - name: Check tag format
        id: check_tag
        run: |
          TAG_NAME="${{ github.ref_name }}"
          echo "Tag received: $TAG_NAME"
          # Simple check: if tag contains a hyphen like '-rc', '-beta', it's a prerelease
          if [[ "$TAG_NAME" == *"-"* ]]; then
            echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
            echo "Detected prerelease: $TAG_NAME"
          else
            echo "is_prerelease=false" >> "$GITHUB_OUTPUT"
            echo "Detected full release: $TAG_NAME"
          fi
          # Output the tag name for use in artifact naming
          echo "tag_name=$TAG_NAME" >> "$GITHUB_OUTPUT"

  # Job to create the initial draft GitHub Release
  create_release:
    name: Create Draft Release
    runs-on: ubuntu-latest
    needs: check_release_type
    outputs:
      # Pass the upload URL to subsequent jobs
      upload_url: ${{ steps.create_release.outputs.upload_url }}
    steps:
      - name: Create Draft Release
        id: create_release
        # Use specific latest v2 version to ensure updates
        uses: softprops/action-gh-release@v2.0.6
        with:
          # Use the tag name from the check job
          tag_name: ${{ needs.check_release_type.outputs.tag_name }}
          # Create as a draft initially
          draft: true
          # Set prerelease status based on check job
          prerelease: ${{ needs.check_release_type.outputs.is_prerelease }}
          # No files uploaded in this step, just create the release structure
          files: ""
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Job to build the crate for various targets
  build_package:
    name: Build for ${{ matrix.target }}
    # Requires the draft release to be created first
    needs: [check_release_type, create_release]
    # Run on the OS specified in the matrix
    runs-on: ${{ matrix.os }}
    # Define the build matrix
    strategy:
      fail-fast: false # Don't cancel all jobs if one fails
      matrix:
        target:
          # Linux
          - x86_64-unknown-linux-musl # x86_64, static linking
          - aarch64-unknown-linux-musl # ARM64, static linking
          - riscv64gc-unknown-linux-gnu # RISC-V 64 (using gnu, static linking harder)
          # Windows
          - x86_64-pc-windows-msvc    # x86_64
          - aarch64-pc-windows-msvc   # ARM64
          # macOS
          - x86_64-apple-darwin       # Intel
          - aarch64-apple-darwin      # Apple Silicon
        include:
          # Linux runners
          - target: x86_64-unknown-linux-musl
            os: ubuntu-latest
          - target: aarch64-unknown-linux-musl
            os: ubuntu-latest
          - target: riscv64gc-unknown-linux-gnu
            os: ubuntu-latest
          # Windows runners
          - target: x86_64-pc-windows-msvc
            os: windows-latest
          - target: aarch64-pc-windows-msvc
            os: windows-latest
          # macOS runners
          - target: x86_64-apple-darwin
            os: macos-latest
          - target: aarch64-apple-darwin
            os: macos-latest

    steps:
      # 1. Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v4 # Use latest major version

      # 2. Install Rust toolchain
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable # Stable should be fine
        with:
          targets: ${{ matrix.target }} # Install the specific target for cross-compilation

      # 3. Install cross-compilation dependencies (Linux only)
      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update -y
          # Install musl-tools if a musl target is being built
          if [[ "${{ matrix.target }}" == *"-musl" ]]; then
            sudo apt-get install -y musl-tools
          fi
          # Install cross-compilers based on target architecture
          if [[ "${{ matrix.target }}" == "aarch64-unknown-linux-musl" ]]; then
            sudo apt-get install -y gcc-aarch64-linux-gnu
            echo "CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_LINKER=aarch64-linux-gnu-gcc" >> $GITHUB_ENV
          elif [[ "${{ matrix.target }}" == "riscv64gc-unknown-linux-gnu" ]]; then
            sudo apt-get install -y gcc-riscv64-linux-gnu
            echo "CARGO_TARGET_RISCV64GC_UNKNOWN_LINUX_GNU_LINKER=riscv64-linux-gnu-gcc" >> $GITHUB_ENV
          fi

      # 4. Build the binary
      - name: Build binary
        run: cargo build --verbose --release --target ${{ matrix.target }}
        env:
           RUSTFLAGS: ${{ (contains(matrix.target, 'pc-windows-msvc') && format('{0} -C target-feature=+crt-static', env.RUSTFLAGS)) || env.RUSTFLAGS }}

      # 5. Prepare package artifacts (archive the binary)
      - name: Prepare package artifacts
        id: prepare_package
        shell: bash
        run: |
          TARGET="${{ matrix.target }}"
          TAG_NAME="${{ needs.check_release_type.outputs.tag_name }}"
          STAGING_DIR="staging"
          # Use the BINARY_NAME env var here
          ARCHIVE_NAME="${{ env.BINARY_NAME }}-${TAG_NAME}-${TARGET}"
          SRC_DIR="target/$TARGET/release"
          EXE_SUFFIX=""
          CONTENT_TYPE="" # Determine content type for upload

          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            EXE_SUFFIX=".exe"
          fi
          # Use the BINARY_NAME env var here
          SRC_PATH="$SRC_DIR/${{ env.BINARY_NAME }}$EXE_SUFFIX"

          echo "Looking for binary at: $SRC_PATH"
          if [[ ! -f "$SRC_PATH" ]]; then
            echo "Error: Binary not found!"
            ls -R "$SRC_DIR" || echo "Could not list $SRC_DIR"
            exit 1
          fi
          echo "Binary found."

          mkdir -p "$STAGING_DIR"
          echo "Created staging directory: $STAGING_DIR"
          cp "$SRC_PATH" "$STAGING_DIR/"
          echo "Copied binary to staging directory."

          [[ -f "README.md" ]] && cp "README.md" "$STAGING_DIR/" && echo "Copied README.md"
          [[ -f "LICENSE" ]] && cp "LICENSE" "$STAGING_DIR/" && echo "Copied LICENSE"

          ARCHIVE_PATH=""
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            ARCHIVE_PATH="$ARCHIVE_NAME.zip"
            CONTENT_TYPE="application/zip"
            powershell Compress-Archive -Path "$STAGING_DIR/*" -DestinationPath "$ARCHIVE_PATH"
          else
            ARCHIVE_PATH="$ARCHIVE_NAME.tar.gz"
            CONTENT_TYPE="application/gzip"
            tar czvf "$ARCHIVE_PATH" -C "$STAGING_DIR" .
          fi
          echo "Created archive: $ARCHIVE_PATH"

          # Output archive path, filename, and content type
          # This uses the recommended GITHUB_OUTPUT method
          echo "archive_path=$ARCHIVE_PATH" >> "$GITHUB_OUTPUT"
          echo "archive_filename=$(basename $ARCHIVE_PATH)" >> "$GITHUB_OUTPUT"
          echo "archive_content_type=$CONTENT_TYPE" >> "$GITHUB_OUTPUT"
          echo "Set outputs: path=$ARCHIVE_PATH, filename=$(basename $ARCHIVE_PATH), type=$CONTENT_TYPE"

      # 6. Upload the artifact to the existing draft release
      - name: Upload Release Asset
        # Use specific latest v1 version
        uses: actions/upload-release-asset@v1.0.2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          # Get the upload URL from the 'create_release' job
          upload_url: ${{ needs.create_release.outputs.upload_url }}
          # Path to the asset file created in the previous step
          asset_path: ${{ steps.prepare_package.outputs.archive_path }}
          # Name for the asset file
          asset_name: ${{ steps.prepare_package.outputs.archive_filename }}
          # Content type of the asset
          asset_content_type: ${{ steps.prepare_package.outputs.archive_content_type }}

  # Job to finalize the release: create checksums, upload them, and publish the release
  publish_release:
    name: Publish Release
    runs-on: ubuntu-latest
    # This job depends on the draft release being created and all matrix jobs finishing
    needs: [check_release_type, create_release, build_package]
    steps:
      # 1. Install GitHub CLI
      - name: Install GitHub CLI
        run: |
          if ! command -v gh &> /dev/null; then
             echo "GitHub CLI not found, installing..."
             sudo apt-get update && sudo apt-get install -y gh
          fi

      # 2. Download all release assets (uploaded by build_package jobs)
      - name: Download Release Assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_NAME: ${{ needs.check_release_type.outputs.tag_name }}
        run: |
          mkdir release-assets
          cd release-assets
          echo "Downloading assets for tag $TAG_NAME from ${{ github.repository }}..."
          # Download assets from the specific release tag
          # Note: Assets are downloaded from the draft release created earlier
          gh release download "$TAG_NAME" --repo "${{ github.repository }}" --pattern '*'
          echo "Download complete. Files:"
          ls -l

      # 3. Generate SHA256 checksums
      - name: Create Checksums File
        run: |
          cd release-assets
          # Handle case where no assets were downloaded (e.g., build failure)
          if [ -z "$(ls -A .)" ]; then
             echo "No assets found to checksum."
             # Create an empty checksum file or skip checksum generation
             touch ../SHA256SUMS
          else
             sha256sum ./* > ../SHA256SUMS
             echo "Generated SHA256SUMS file:"
             cat ../SHA256SUMS
          fi


      # 4. Publish Release (Update draft to final) and Upload Checksums
      - name: Publish Release and Upload Checksums
        # Use specific latest v2 version to ensure updates
        uses: softprops/action-gh-release@v2.0.6
        with:
          # Find the release by tag
          tag_name: ${{ needs.check_release_type.outputs.tag_name }}
          # Upload the checksums file (even if empty)
          files: SHA256SUMS
          # Mark the release as non-draft (publish it)
          draft: false
          # Set prerelease status correctly
          prerelease: ${{ needs.check_release_type.outputs.is_prerelease }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
