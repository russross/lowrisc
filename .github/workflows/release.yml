# .github/workflows/release.yml
# Workflow name
name: Release Build and Publish

# Controls when the workflow will run
on:
  push:
    tags:
      - 'v*.*.*' # Trigger on tags like v1.0.0, v2.3.4 etc.

# Permissions needed by the workflow
permissions:
  contents: write # Needed to create releases and upload release assets

# Default settings for all jobs
defaults:
  run:
    shell: bash

# Environment variables available to all jobs
env:
  # Fail the build if there are warnings
  RUSTFLAGS: --deny warnings
  # Set the binary name of your crate here
  BINARY_NAME: "lowrisc"

jobs:
  # Optional: Job to check if the tag is a pre-release or full release
  # based on the tag format (e.g., v1.0.0-rc1 vs v1.0.0)
  check_release_type:
    name: Check Release Type
    runs-on: ubuntu-latest
    outputs:
      is_prerelease: ${{ steps.check_tag.outputs.is_prerelease }}
      tag_name: ${{ steps.check_tag.outputs.tag_name }}
    steps:
      - name: Check tag format
        id: check_tag
        run: |
          TAG_NAME="${{ github.ref_name }}"
          echo "Tag received: $TAG_NAME"
          # Simple check: if tag contains a hyphen like '-rc', '-beta', it's a prerelease
          if [[ "$TAG_NAME" == *"-"* ]]; then
            echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
            echo "Detected prerelease: $TAG_NAME"
          else
            echo "is_prerelease=false" >> "$GITHUB_OUTPUT"
            echo "Detected full release: $TAG_NAME"
          fi
          # Output the tag name for use in artifact naming
          echo "tag_name=$TAG_NAME" >> "$GITHUB_OUTPUT"

  # Job to build the crate for various targets
  build_package:
    name: Build for ${{ matrix.target }}
    # Requires the check_release_type job to complete first
    needs: check_release_type
    # Run on the OS specified in the matrix
    runs-on: ${{ matrix.os }}
    # Define the build matrix
    strategy:
      fail-fast: false # Don't cancel all jobs if one fails
      matrix:
        target:
          # Linux
          - x86_64-unknown-linux-musl # x86_64, static linking
          - aarch64-unknown-linux-musl # ARM64, static linking
          - riscv64gc-unknown-linux-gnu # RISC-V 64 (using gnu, static linking harder)
          # Windows
          - x86_64-pc-windows-msvc    # x86_64
          - aarch64-pc-windows-msvc   # ARM64
          # macOS
          - x86_64-apple-darwin       # Intel
          - aarch64-apple-darwin      # Apple Silicon
        include:
          # Linux runners
          - target: x86_64-unknown-linux-musl
            os: ubuntu-latest
          - target: aarch64-unknown-linux-musl
            os: ubuntu-latest
          - target: riscv64gc-unknown-linux-gnu
            os: ubuntu-latest
          # Windows runners
          - target: x86_64-pc-windows-msvc
            os: windows-latest
          - target: aarch64-pc-windows-msvc
            os: windows-latest
          # macOS runners
          - target: x86_64-apple-darwin
            os: macos-latest # Use macos-13 for Intel if needed, latest should work
          - target: aarch64-apple-darwin
            os: macos-latest # Use macos-14 for Apple Silicon if needed

    steps:
      # 1. Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. Install Rust toolchain
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }} # Install the specific target for cross-compilation

      # 3. Install cross-compilation dependencies (Linux only)
      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update -y
          # Install musl-tools if a musl target is being built
          if [[ "${{ matrix.target }}" == *"-musl" ]]; then
            sudo apt-get install -y musl-tools
          fi
          # Install cross-compilers based on target architecture
          if [[ "${{ matrix.target }}" == "aarch64-unknown-linux-musl" ]]; then
            sudo apt-get install -y gcc-aarch64-linux-gnu
            # Set linker for cargo
            echo "CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_LINKER=aarch64-linux-gnu-gcc" >> $GITHUB_ENV
          elif [[ "${{ matrix.target }}" == "riscv64gc-unknown-linux-gnu" ]]; then
            sudo apt-get install -y gcc-riscv64-linux-gnu
            # Set linker for cargo
            echo "CARGO_TARGET_RISCV64GC_UNKNOWN_LINUX_GNU_LINKER=riscv64-linux-gnu-gcc" >> $GITHUB_ENV
          fi

      # 4. Build the binary
      - name: Build binary
        # Add flags for static CRT linking on Windows MSVC targets
        run: cargo build --verbose --release --target ${{ matrix.target }}
        env:
           # Apply static CRT flag only for windows-msvc targets
           RUSTFLAGS: ${{ (contains(matrix.target, 'pc-windows-msvc') && format('{0} -C target-feature=+crt-static', env.RUSTFLAGS)) || env.RUSTFLAGS }}


      # 5. Prepare package artifacts (archive the binary)
      - name: Prepare package artifacts
        id: prepare_package # Give this step an ID to reference its outputs
        shell: bash # Use bash for consistency, even on Windows runners
        run: |
          # Define variables
          TARGET="${{ matrix.target }}"
          TAG_NAME="${{ needs.check_release_type.outputs.tag_name }}" # Get tag from previous job
          STAGING_DIR="staging"
          ARCHIVE_NAME="${{ env.BINARY_NAME }}-${TAG_NAME}-${TARGET}"

          # Determine source path and executable extension
          SRC_DIR="target/$TARGET/release"
          EXE_SUFFIX=""
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            EXE_SUFFIX=".exe"
          fi
          SRC_PATH="$SRC_DIR/${{ env.BINARY_NAME }}$EXE_SUFFIX"

          # Check if binary exists
          echo "Looking for binary at: $SRC_PATH"
          if [[ ! -f "$SRC_PATH" ]]; then
            echo "Error: Binary not found!"
            echo "Listing contents of $SRC_DIR:"
            ls -R "$SRC_DIR" || echo "Could not list $SRC_DIR"
            exit 1
          fi
          echo "Binary found."

          # Create staging directory
          mkdir -p "$STAGING_DIR"
          echo "Created staging directory: $STAGING_DIR"

          # Copy binary to staging directory
          cp "$SRC_PATH" "$STAGING_DIR/"
          echo "Copied binary to staging directory."

          # Optional: Add other files like README, LICENSE
          # Check if files exist before copying
          [[ -f "README.md" ]] && cp "README.md" "$STAGING_DIR/" && echo "Copied README.md"
          [[ -f "LICENSE" ]] && cp "LICENSE" "$STAGING_DIR/" && echo "Copied LICENSE"

          # Determine archive name and format, then create the archive
          ARCHIVE_PATH=""
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            ARCHIVE_PATH="$ARCHIVE_NAME.zip"
            # Use PowerShell's Compress-Archive on Windows runners for built-in zip creation
            powershell Compress-Archive -Path "$STAGING_DIR/*" -DestinationPath "$ARCHIVE_PATH"
          else
            ARCHIVE_PATH="$ARCHIVE_NAME.tar.gz"
            # Use tar for Linux/macOS
            tar czvf "$ARCHIVE_PATH" -C "$STAGING_DIR" .
          fi
          echo "Created archive: $ARCHIVE_PATH"

          # Make archive path available to subsequent steps via output
          echo "archive_path=$ARCHIVE_PATH" >> "$GITHUB_OUTPUT"
          echo "Set output archive_path=$ARCHIVE_PATH"


      # 6. Upload the created archive as a release asset
      - name: Upload Release Asset
        uses: softprops/action-gh-release@v2 # Use latest major version
        with:
          # Use the output from the previous step as the file to upload
          files: ${{ steps.prepare_package.outputs.archive_path }}
          # Mark as draft or pre-release based on the tag check
          draft: false
          prerelease: ${{ needs.check_release_type.outputs.is_prerelease }}
        env:
          # The GITHUB_TOKEN is automatically provided by GitHub Actions
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Job to create and upload checksums after all builds are done
  create_checksums:
    name: Create Checksums
    runs-on: ubuntu-latest
    # This job depends on all matrix jobs in 'build_package' finishing successfully
    needs: [check_release_type, build_package]
    steps:
      # 1. Install GitHub CLI (usually pre-installed on runners, but good practice)
      - name: Install GitHub CLI
        run: |
          # Check if gh is installed, install if not (adjust for runner if needed)
          if ! command -v gh &> /dev/null; then
             echo "GitHub CLI not found, installing..."
             sudo apt-get update && sudo apt-get install -y gh
          fi

      # 2. Download all release assets for the current tag
      - name: Download Release Assets
        env:
          # Use the automatically provided token
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # Get the tag name from the initial check job
          TAG_NAME: ${{ needs.check_release_type.outputs.tag_name }}
        run: |
          # Create a directory to store downloaded assets
          mkdir release-assets
          cd release-assets
          echo "Downloading assets for tag $TAG_NAME from ${{ github.repository }}..."
          # Download all assets associated with the release tag
          gh release download "$TAG_NAME" --repo "${{ github.repository }}" --pattern '*'
          echo "Download complete. Files:"
          ls -l

      # 3. Generate SHA256 checksums for the downloaded assets
      - name: Create Checksums File
        run: |
          cd release-assets
          # Generate checksums and save to a file in the parent directory
          sha256sum ./* > ../SHA256SUMS
          echo "Generated SHA256SUMS file:"
          cat ../SHA256SUMS

      # 4. Upload the checksums file to the same release
      - name: Upload Checksums File
        uses: softprops/action-gh-release@v2
        with:
          files: SHA256SUMS # Upload the generated checksum file
          # Ensure draft/prerelease status matches the rest of the release
          draft: false
          prerelease: ${{ needs.check_release_type.outputs.is_prerelease }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
